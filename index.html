<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>3日間のお世話ゲーム（プロトタイプ）</title>
  <style>
    :root{
      --bg:#eef8ff;
      --card:rgba(255,255,255,.78);
      --card2:rgba(255,255,255,.62);
      --text:#0f172a;
      --muted:#475569;
      --line:rgba(15,23,42,.12);

      --btn:#2dd4bf;
      --btnText:#042f2e;

      --btn2:#60a5fa;
      --danger:#fb7185;
      --ok:#34d399;

      --shadow: 0 16px 38px rgba(15,23,42,.12);
      --radius: 18px;
    }
    *{ box-sizing:border-box; }
    body{
      margin:0;
      font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Yu Gothic", "Meiryo", sans-serif;
      color:var(--text);
      background:
        radial-gradient(1200px 700px at 15% 0%, rgba(45,212,191,.26), transparent 55%),
        radial-gradient(900px 600px at 85% 10%, rgba(96,165,250,.22), transparent 55%),
        radial-gradient(900px 900px at 45% 110%, rgba(167,243,208,.30), transparent 55%),
        linear-gradient(180deg, #f6fdff, #eef8ff 35%, #f7fbff);
      min-height:100vh;
      overflow-x:hidden;
    }
    .wrap{ max-width:980px; margin:0 auto; padding:18px; }

    .topbar{
      display:flex; align-items:center; justify-content:space-between;
      padding:12px 14px;
      background: var(--card2);
      border:1px solid var(--line);
      border-radius: 16px;
      box-shadow: var(--shadow);
      backdrop-filter: blur(10px);
    }
    .brand{ display:flex; gap:10px; align-items:center; }
    .dot{
      width:12px; height:12px; border-radius:999px;
      background: linear-gradient(135deg, rgba(45,212,191,.95), rgba(96,165,250,.90));
      box-shadow: 0 0 18px rgba(45,212,191,.28);
    }
    .title{ font-weight:800; letter-spacing:.02em; font-size:14px; color:rgba(15,23,42,.92); }
    .sub{ font-size:12px; color:var(--muted); margin-top:2px; }

    .pill{
      display:flex; align-items:center; gap:8px;
      padding:8px 10px;
      border-radius:999px;
      background: rgba(255,255,255,.55);
      border:1px solid var(--line);
      font-size:12px;
      color: rgba(15,23,42,.85);
      user-select:none;
    }
    .pill small{ color:var(--muted); }

    .grid{
      display:grid;
      gap:14px;
      grid-template-columns: 1.2fr .8fr;
      margin-top:14px;
    }
    @media (max-width: 880px){
      .grid{ grid-template-columns: 1fr; }
    }

    .card{
      background: var(--card);
      border: 1px solid var(--line);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      overflow:hidden;
      position:relative;
    }
    .card .inner{ padding:14px; }
    .card h2{
      margin:0;
      font-size:14px;
      letter-spacing:.02em;
      color:rgba(15,23,42,.92);
      font-weight:800;
    }
    .card p{
      margin:10px 0 0 0;
      font-size:13px;
      line-height:1.75;
      color: rgba(15,23,42,.80);
    }
    .muted{ color:var(--muted); }

    .btnrow{ display:flex; gap:10px; flex-wrap:wrap; margin-top:12px; }
    button{
      border:0;
      background:none;
      color:inherit;
      font:inherit;
      cursor:pointer;
    }
    .btn{
      padding:10px 12px;
      border-radius:14px;
      background: linear-gradient(135deg, rgba(45,212,191,.95), rgba(45,212,191,.78));
      color: var(--btnText);
      font-weight:800;
      box-shadow: 0 12px 24px rgba(45,212,191,.14);
      border:1px solid rgba(15,23,42,.10);
      transition: transform .08s ease, filter .12s ease;
    }
    .btn:hover{ filter:brightness(1.03); }
    .btn:active{ transform: translateY(1px) scale(.99); }

    .btn.secondary{
      background: rgba(255,255,255,.55);
      color: rgba(15,23,42,.90);
      border:1px solid var(--line);
      box-shadow:none;
      font-weight:750;
    }
    .btn.blue{
      background: linear-gradient(135deg, rgba(96,165,250,.92), rgba(96,165,250,.72));
      color:#071223;
      box-shadow: 0 12px 24px rgba(96,165,250,.14);
    }
    .btn.danger{
      background: linear-gradient(135deg, rgba(251,113,133,.92), rgba(251,113,133,.72));
      color:#2a0b10;
      box-shadow: 0 12px 24px rgba(251,113,133,.14);
    }
    .btn:disabled{
      opacity:.50;
      cursor:not-allowed;
      filter:saturate(.7);
    }

    .screen{ display:none; }
    .screen.active{ display:block; }

    .stage{
      display:flex; align-items:center; justify-content:center;
      min-height: 420px;
      position:relative;
      padding:10px;
    }
    .charWrap{
      width: min(420px, 100%); height: 320px;
      display:grid; place-items:center;
      position:relative;
      user-select:none;
    }
    .charImg{
      width: 300px;
      height: 300px;
      object-fit:contain;
      filter: drop-shadow(0 20px 30px rgba(15,23,42,.18));
      transform-origin: 50% 80%;
    }
    /* ここから：誕生後は2人で並ぶ（小さく生まれ、3日かけて成長） */
    .charPair{
      position:absolute; inset:0;
      --growA: .50;
      --growB: .36;
      --sep: 96px;
      pointer-events:none;
    }
    .charTwin{
      position:absolute;
      bottom: 0;
      left: 50%;
      width: 280px;
      height: 280px;
      object-fit:contain;
      transform-origin: 50% 85%;
      filter: drop-shadow(0 20px 30px rgba(15,23,42,.18));
    }
    .charTwin.left{ transform: translateX(calc(-50% - var(--sep))) scale(var(--growA)) rotate(-3deg); }
    .charTwin.right{ transform: translateX(calc(-50% + var(--sep))) scale(var(--growB)) rotate(3deg); }

    /* 状態に合わせた動き（ラベルは出さない） */
    .charPair.k-happy{ animation: bop 1.2s ease-in-out infinite; }
    .charPair.k-ok{ animation: floaty 3.6s ease-in-out infinite; }
    .charPair.k-sad{ animation: droop 2.6s ease-in-out infinite; }
    .charPair.k-ended{ animation: droop 3.2s ease-in-out infinite; }
    .charPair.k-cry{ animation: crymix 1.0s ease-in-out infinite; }
    @keyframes crymix{
      0%,100%{ transform: translateY(8px) rotate(0deg); }
      25%{ transform: translateY(10px) rotate(-.8deg) translateX(-2px); }
      75%{ transform: translateY(10px) rotate(.8deg) translateX(2px); }
    }

    /* 復活の違和感：色味だけ少しズレる（動きは邪魔しない） */
    .charPair.uncanny .charTwin{
      filter:
        drop-shadow(0 20px 30px rgba(15,23,42,.18))
        hue-rotate(14deg)
        saturate(1.15)
        contrast(1.08);
    }

    /* 終了：灰色寄り */
    .charPair.k-ended .charTwin{
      filter: grayscale(.9) brightness(.88) drop-shadow(0 20px 30px rgba(15,23,42,.18));
    }
    /* ここまで：2人表示 */

    .floaty{ animation: floaty 3.6s ease-in-out infinite; }
    @keyframes floaty{
      0%,100%{ transform: translateY(0); }
      50%{ transform: translateY(-10px); }
    }
    .bop{ animation: bop 1.2s ease-in-out infinite; }
    @keyframes bop{
      0%,100%{ transform: translateY(0) scale(1); }
      50%{ transform: translateY(-8px) scale(1.01); }
    }
    .droop{ animation: droop 2.6s ease-in-out infinite; }
    @keyframes droop{
      0%,100%{ transform: translateY(0) rotate(0deg) scale(.995); filter: brightness(.98) contrast(1.02) drop-shadow(0 20px 30px rgba(15,23,42,.18)); }
      50%{ transform: translateY(10px) rotate(-1.5deg) scale(.985); filter: brightness(.86) contrast(1.02) drop-shadow(0 20px 30px rgba(15,23,42,.18)); }
    }
    .shake{ animation: shake .6s ease-in-out infinite; }
    @keyframes shake{
      0%,100%{ transform: translateX(0) rotate(0deg); }
      25%{ transform: translateX(-3px) rotate(-.8deg); }
      75%{ transform: translateX(3px) rotate(.8deg); }
    }
    .glitch{
      filter:
        drop-shadow(0 20px 30px rgba(15,23,42,.18))
        hue-rotate(14deg)
        saturate(1.15)
        contrast(1.08);
      animation: glitch 1.2s steps(2) infinite;
    }
    @keyframes glitch{
      0%,100%{ transform: translate(0,0) scale(1); }
      20%{ transform: translate(-1px, 1px) scale(1.001); }
      40%{ transform: translate(2px, -1px) scale(.999); }
      60%{ transform: translate(-2px, -1px) scale(1.002); }
      80%{ transform: translate(1px, 2px) scale(1); }
    }
    .tear{
      position:absolute;
      left:50%;
      top:74px;
      width: 22px; height: 22px;
      border-radius: 999px;
      background: radial-gradient(circle at 35% 35%, rgba(255,255,255,.95), rgba(96,165,250,.85) 35%, rgba(96,165,250,.18) 70%, transparent 75%);
      filter: blur(.1px);
      opacity:0;
      transform: translate(-110px, 18px) rotate(18deg);
      animation: tear 1.4s ease-in-out infinite;
      pointer-events:none;
    }
    @keyframes tear{
      0%{ opacity:0; transform: translate(-110px, 18px) rotate(18deg) scale(.8); }
      20%{ opacity:.9; }
      80%{ opacity:.05; transform: translate(-104px, 56px) rotate(18deg) scale(1); }
      100%{ opacity:0; transform: translate(-104px, 56px) rotate(18deg) scale(1); }
    }
    .tear.on{ opacity:1; }

    .poop{
      position:absolute;
      width: 20px; height: 16px;
      border-radius: 8px 8px 12px 12px;
      background: linear-gradient(180deg, rgba(15,23,42,.10), rgba(15,23,42,.28));
      border:1px solid rgba(15,23,42,.14);
      opacity:0;
      transform: translate(0,0) scale(.95);
      filter: blur(.1px);
      pointer-events:none;
    }
    .poop.on{ opacity:.70; }
    .poop#po1{ left:36px; top:230px; transform: rotate(-10deg); }
    .poop#po2{ right:42px; top:246px; transform: rotate(12deg); }
    .poop#po3{ left: 86px; top:268px; transform: rotate(6deg) scale(.9); }
    .poop#po4{ right: 96px; top:276px; transform: rotate(-8deg) scale(.92); }

    .hearts{
      display:flex; gap:6px; align-items:center;
      padding:8px 10px; border-radius:14px;
      background: rgba(255,255,255,.55);
      border:1px solid var(--line);
      width: fit-content;
    }
    .heart{
      width: 14px; height: 14px;
      transform: rotate(45deg);
      position:relative;
      opacity:.30;
      filter: drop-shadow(0 2px 6px rgba(251,113,133,.20));
    }
    .heart::before,.heart::after{
      content:"";
      position:absolute;
      width: 14px; height: 14px;
      border-radius: 50%;
      background: rgba(251,113,133,.85);
      left:0; top:0;
    }
    .heart::after{ left:-7px; }
    .heart.on{ opacity:1; }
    .heart.on::before,.heart.on::after{ background: rgba(251,113,133,.95); }

    .choiceGrid{
      display:grid;
      grid-template-columns: repeat(2, 1fr);
      gap:12px;
      margin-top:12px;
    }
    @media (max-width:520px){ .choiceGrid{ grid-template-columns:1fr; } }
    .choice{
      border:1px solid var(--line);
      border-radius: 18px;
      background: rgba(255,255,255,.55);
      padding:12px;
      display:flex;
      gap:12px;
      align-items:center;
      transition: transform .12s ease, background .2s ease;
    }
    .choice:hover{ transform: translateY(-1px); background: rgba(255,255,255,.72); }
    .choice.selected{ border-color: rgba(45,212,191,.55); background: rgba(45,212,191,.14); }
    .choice.selected .tiny{ opacity: .95; }
    .choice img{
      width:72px; height:72px; object-fit:contain;
      filter: drop-shadow(0 12px 16px rgba(15,23,42,.14));
    }
    .choice .ctext{ flex:1; }
    .choice .ctext .cname{ font-weight:900; font-size:13px; }
    .choice .ctext .cdesc{ font-size:12px; margin-top:4px; color: var(--muted); line-height:1.55; }

    .mapGrid{
      display:grid;
      grid-template-columns: repeat(4, 1fr);
      gap:10px;
      margin-top:12px;
    }
    .tile{
      height:84px;
      border-radius:16px;
      border:1px solid var(--line);
      background: rgba(255,255,255,.50);
      position:relative;
      overflow:hidden;
      display:grid;
      place-items:center;
      transition: transform .12s ease, background .2s ease;
    }
    .tile:hover{ transform: translateY(-1px); background: rgba(255,255,255,.68); }
    .tile.revealed{ background: rgba(45,212,191,.14); }
    .spark{
      position:absolute; inset:-40%;
      background:
        radial-gradient(circle at 30% 40%, rgba(45,212,191,.18), transparent 45%),
        radial-gradient(circle at 70% 60%, rgba(96,165,250,.14), transparent 45%);
      opacity:0;
      transform: rotate(12deg);
    }
    .tile.revealed .spark{ opacity:1; animation: spin 3.6s linear infinite; }
    @keyframes spin{
      from{ transform: rotate(0deg); }
      to{ transform: rotate(360deg); }
    }
    .tile span{
      font-size:12px;
      color: rgba(15,23,42,.72);
      opacity:.85;
    }
    .foundImg{
      width:60px; height:60px; object-fit:contain;
      filter: drop-shadow(0 10px 16px rgba(15,23,42,.16));
      opacity:.0;
      transform: translateY(6px) scale(.98);
      transition: opacity .25s ease, transform .25s ease;
    }
    .tile.found .foundImg{ opacity:1; transform: translateY(0) scale(1); }

    .overlay{
      position:fixed; inset:0;
      display:none;
      place-items:center;
      background: rgba(15,23,42,.45);
      backdrop-filter: blur(6px);
      z-index: 50;
      padding:18px;
    }
    .overlay.on{ display:grid; }
    .modal{
      width:min(720px, 96vw);
      background: rgba(255,255,255,.88);
      border:1px solid var(--line);
      border-radius: 18px;
      box-shadow: var(--shadow);
      overflow:hidden;
    }
    .modal .mhead{
      padding:12px 14px;
      border-bottom:1px solid var(--line);
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
    }
    .modal .mhead .mtitle{ font-weight:900; font-size:13px; letter-spacing:.02em; }
    .modal .mbody{ padding:14px; }
    .modal .mnote{ font-size:12px; color: var(--muted); line-height:1.7; }

    .thanks{
      min-height: 520px;
      display:grid;
      place-items:center;
      text-align:center;
    }
    .thanks .word{
      font-size: 34px;
      font-weight: 900;
      letter-spacing:.08em;
      color: rgba(15,23,42,.92);
      text-shadow: 0 18px 42px rgba(15,23,42,.12);
    }
    .fade{ animation: fadeIn 1.2s ease both; }
    @keyframes fadeIn{
      from{ opacity:0; transform: translateY(6px); }
      to{ opacity:1; transform: translateY(0); }
    }

    .tabs{ display:flex; gap:8px; flex-wrap:wrap; margin-top:12px; }
    .tab{
      padding:8px 10px;
      border-radius:999px;
      border:1px solid var(--line);
      background: rgba(255,255,255,.55);
      font-size:12px;
      color: rgba(15,23,42,.88);
      opacity:.95;
    }
    .tab.active{ background: rgba(96,165,250,.14); border-color: rgba(96,165,250,.28); }
    .logBox{
      margin-top:12px;
      border:1px solid var(--line);
      border-radius:18px;
      background: rgba(255,255,255,.55);
      padding:12px;
      overflow:auto;
      max-height: 360px;
    }
    .logLine{
      font-size:12px;
      line-height:1.8;
      color: rgba(15,23,42,.82);
      border-bottom:1px dashed rgba(15,23,42,.14);
      padding:6px 0;
    }
    .logLine:last-child{ border-bottom:0; }
    canvas{ max-width:100%; }

    .tiny{ font-size:12px; color: var(--muted); }

    .linkBox{
      margin-top:10px;
      padding:10px 12px;
      border-radius:14px;
      border:1px solid var(--line);
      background: rgba(255,255,255,.55);
      display:flex;
      gap:10px;
      align-items:center;
      justify-content:space-between;
      flex-wrap:wrap;
    }
    .linkBox input{
      flex:1;
      min-width: 240px;
      padding:10px 10px;
      border-radius:12px;
      background: rgba(255,255,255,.78);
      border:1px solid rgba(15,23,42,.14);
      color: rgba(15,23,42,.92);
      outline:none;
      font-size:12px;
    }

    select.sel{
      flex:1;
      min-width: 240px;
      padding:10px 10px;
      border-radius:12px;
      background: rgba(255,255,255,.78);
      border:1px solid rgba(15,23,42,.14);
      color: rgba(15,23,42,.92);
      outline:none;
      font-size:12px;
      appearance:none;
    }

    .cornerHint{
      position:absolute;
      top:10px; right:10px;
      font-size:12px;
      color: rgba(15,23,42,.70);
      opacity:.90;
      display:flex; align-items:center; gap:8px;
    }
    .toggle{
      width:42px; height:22px; border-radius:999px;
      background: rgba(15,23,42,.08);
      border:1px solid var(--line);
      position:relative;
      flex: 0 0 auto;
    }
    .toggle::after{
      content:"";
      width:18px; height:18px; border-radius:999px;
      position:absolute; top:1px; left:1px;
      background: rgba(15,23,42,.45);
      transition: left .18s ease, background .18s ease;
    }
    .toggle.on{ background: rgba(45,212,191,.22); border-color: rgba(45,212,191,.28); }
    .toggle.on::after{ left:21px; background: rgba(45,212,191,.92); }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="topbar">
      <div class="brand">
        <div class="dot"></div>
        <div>
          <div class="title">3日間のお世話ゲーム</div>
          <div class="sub" id="subline">記録だけが残る</div>
        </div>
      </div>
      <div class="pill" id="modePill">
        <span id="modeLabel">プレイ</span>
        <small id="modeMeta">ローカル保存</small>
      </div>
    </div>

    <div class="screen active" id="scr_intro">
      <div class="grid">
        <div class="card">
          <div class="inner">
            <h2>はじめに</h2>
            <p class="fade">
              ある日、あなたのもとに一通のメッセージが届く。<br>
              「なくしたものを探しています。見つけた人に、3日間だけ預けます。」<br>
              地図だけが添えられている。
            </p>

            <p class="muted">
              最初に、あなたの相棒と、呼ばれたい名前を決める。<br>
              それから、マカロンの形をした「探しもの」を探しに行く。
            </p>

            <div style="margin-top:12px;">
              <div class="tiny" style="margin-bottom:6px;">呼ばれたい名前</div>
              <div class="btnrow" style="margin-top:0;">
                <input id="playerName" placeholder="○○（あなたの呼ばれ方）">
                <button class="btn blue" id="btn_start" disabled>はじめる</button>
                <button class="btn secondary" id="btn_new_reset" title="保存を消します">最初から</button>
              </div>
              <p class="tiny" style="margin-top:8px;">名前と選択はこの端末の中だけに保存されます。</p>

              <div style="margin-top:12px;">
                <div class="tiny" style="margin-bottom:6px;">時間設定</div>
                <div class="btnrow" style="margin-top:0;">
                  <select id="timeMode" class="sel">
                    <option value="normal">通常（誕生3分／寿命3日）</option>
                    <option value="fast">テスト（誕生約12秒／寿命約90秒）</option>
                  </select>
                </div>
                <p class="tiny" id="timeModeNote" style="margin-top:6px;"></p>
              </div>

              <div class="linkBox" id="resumeBox" style="display:none; margin-top:12px;">
                <div class="tiny">記録が残っています</div>
                <div class="btnrow" style="margin-top:8px;">
                  <button class="btn" id="btn_resume">つづきから</button>
                </div>
                <p class="tiny" id="resumeMeta" style="margin-top:6px;"></p>
              </div>
            </div>

            <p class="tiny" id="introNeed" style="margin-top:6px;"></p>
          </div>
        </div>

        <div class="card">
          <div class="stage">
            <div class="charWrap">
              <img id="charPreview" class="charImg floaty" alt="character preview" />
            </div>
          </div>
          <div class="inner">
            <h2>相棒</h2>
            <p class="muted">正解はない。あなたが「この子」と思ったもの。</p>
            <div class="choiceGrid" id="charChoices"></div>
            <p class="tiny" id="introPickHint" style="margin-top:10px;">相棒を選ぶと、右の姿が少し変わります。</p>
          </div>
        </div>
      </div>
    </div>

    <div class="screen" id="scr_search">
      <div class="grid">
        <div class="card">
          <div class="inner">
            <h2>探す</h2>
            <p>現実と少しだけずれた空間。光の粒がゆっくり漂っている。</p>
            <p class="muted">どこかに、マカロンの形をしたものがある。</p>
            <div class="mapGrid" id="mapGrid"></div>
            <div class="btnrow">
              <button class="btn secondary" id="btn_back_intro">設定へ戻る</button>
              <button class="btn" id="btn_hint">少しだけ目を慣らす</button>
            </div>
          </div>
        </div>
        <div class="card">
          <div class="inner">
            <h2>気配</h2>
            <p class="muted" id="searchNote">まだ、何も見つからない。</p>
          </div>
        </div>
      </div>
    </div>

    <div class="screen" id="scr_arrival">
      <div class="grid">
        <div class="card">
          <div class="inner">
            <h2>到着</h2>
            <p id="arrivalText">
              見つけたマカロンを持ち帰った。<br>
              しばらくすると、ふわりと浮かび上がるらしい。
            </p>
            <p class="muted">誕生は、あなたの操作では起きない。</p>
            <div class="btnrow">
              <button class="btn secondary" id="btn_back_search">もう一度探す</button>
            </div>
          </div>
        </div>
        <div class="card">
          <div class="stage">
            <div class="charWrap">
              <img id="arrivalImg" class="charImg floaty" alt="macaron" />
            </div>
          </div>
        </div>
      </div>
    </div>

    <div class="screen" id="scr_care">
      <div class="grid">
        <div class="card">
          <div class="inner">
            <div style="display:flex; align-items:center; justify-content:space-between; gap:10px;">
              <h2 id="careTitle">いま</h2>
              <div class="hearts" title="関係の雰囲気">
                <div class="heart" id="h1"></div>
                <div class="heart" id="h2"></div>
                <div class="heart" id="h3"></div>
                <div class="heart" id="h4"></div>
                <div class="heart" id="h5"></div>
              </div>
            </div>

            <p class="muted" id="careHint">言葉ではわからない。表情と動きだけが変わる。</p>

            <div class="btnrow" style="margin-top:10px;">
              <button class="btn" id="btn_food">食事</button>
              <button class="btn" id="btn_outing">お出かけ</button>
              <button class="btn" id="btn_mini">2択ミニゲーム</button>
              <button class="btn" id="btn_clean">排泄除去</button>
              <button class="btn blue" id="btn_drink">ドリンク</button>
              <button class="btn danger" id="btn_macaron">マカロン</button>
              <button class="btn secondary" id="btn_logs">ログ</button>
            </div>

            <div class="linkBox" style="margin-top:12px;">
              <div class="tiny">シッター</div>
              <div style="display:flex; align-items:center; gap:10px;">
                <div class="toggle" id="toggle_sitter" role="switch" aria-checked="false" tabindex="0"></div>
                <div class="tiny" id="sitterNote">時間は止まる</div>
              </div>
            </div>

            <div class="linkBox" id="shareBox" style="display:none;">
              <div class="tiny">共有URL（観察用）</div>
              <input id="shareUrl" readonly>
              <button class="btn secondary" id="btn_copy_share">コピー</button>
            </div>

            <p class="tiny" id="endNote" style="margin-top:10px; display:none;">
              ここから先は、操作できない。記録だけが残る。
            </p>
          </div>
        </div>

        <div class="card">
          <div class="stage">
            <div class="cornerHint" id="cornerHint" style="display:none;">
              <span class="tiny">観察中</span>
            </div>
            <div class="charWrap" id="charWrap">
              <div class="charPair k-ok" id="charPair" aria-hidden="true">
                <img id="charImg" class="charTwin left" alt="character left" />
                <img id="charImg2" class="charTwin right" alt="character right" />
              </div>
              <div class="tear" id="tear"></div>
              <div class="poop" id="po1"></div>
              <div class="poop" id="po2"></div>
              <div class="poop" id="po3"></div>
              <div class="poop" id="po4"></div>
            </div>
          </div>
        </div>
      </div>
    </div>

    <div class="screen" id="scr_end">
      <div class="card">
        <div class="thanks">
          <div>
            <div class="word fade">ありがとう</div>
            <div class="btnrow" style="justify-content:center; margin-top:16px;">
              <button class="btn secondary" id="btn_end_logs">ログを見る</button>
              <button class="btn secondary" id="btn_end_share">共有URL</button>
            </div>
          </div>
        </div>
      </div>
    </div>

    <div class="screen" id="scr_logs">
      <div class="grid">
        <div class="card">
          <div class="inner">
            <h2>ログ</h2>
            <p class="muted">評価はしない。起きたことだけ。</p>

            <canvas id="heartChart" width="640" height="180" style="margin-top:10px; border:1px solid var(--line); border-radius:16px; background: rgba(255,255,255,.70);"></canvas>

            <div class="tabs" id="dayTabs"></div>

            <div class="logBox" id="logBox"></div>

            <div class="btnrow">
              <button class="btn secondary" id="btn_back_care">戻る</button>
              <button class="btn secondary" id="btn_logs_share">共有URL</button>
            </div>
          </div>
        </div>

        <div class="card">
          <div class="inner">
            <h2>共有</h2>
            <p class="muted">このURLを開いた人は、ログとハート推移だけを見られます。操作はできません。</p>
            <div class="linkBox" style="margin-top:12px;">
              <input id="shareUrl2" readonly>
              <button class="btn secondary" id="btn_copy_share2">コピー</button>
            </div>
            <p class="tiny">URLには観察用の情報が入ります。公開範囲に注意してください。</p>
          </div>
        </div>
      </div>
    </div>

    <div class="screen" id="scr_observe">
      <div class="grid">
        <div class="card">
          <div class="inner">
            <h2>観察用ログ</h2>
            <p class="muted">ここでは操作できません。ログとハート推移のみ。</p>
            <canvas id="heartChartObs" width="640" height="180" style="margin-top:10px; border:1px solid var(--line); border-radius:16px; background: rgba(255,255,255,.70);"></canvas>

            <div class="tabs" id="dayTabsObs"></div>
            <div class="logBox" id="logBoxObs"></div>

            <div class="btnrow">
              <button class="btn secondary" id="btn_obs_back">閉じる</button>
            </div>
          </div>
        </div>

        <div class="card">
          <div class="stage">
            <div class="cornerHint">
              <span class="tiny">観察中</span>
            </div>
            <div class="charWrap">
              <div class="charPair k-ok" id="charPairObs" aria-hidden="true">
                <img id="charImgObs" class="charTwin left" alt="character left" />
                <img id="charImgObs2" class="charTwin right" alt="character right" />
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>

  </div>

  <div class="overlay" id="overlay">
    <div class="modal">
      <div class="mhead">
        <div class="mtitle" id="modalTitle">選ぶ</div>
        <button class="btn secondary" id="btn_close_modal">閉じる</button>
      </div>
      <div class="mbody" id="modalBody">
        <div class="mnote" id="modalNote"></div>
        <div class="btnrow" id="modalBtns"></div>
      </div>
    </div>
  </div>

<script>
(() => {
  const APP_KEY = "care3days_save_stage1_v2";

  const ASSETS = {
    // すべて stage1 フォルダに入っている前提
    char: {
      green: { closed: "stage1/green_closed.png", open: "stage1/green_open.png" },
      blue:  { closed: "stage1/blue_closed.png",  open: "stage1/blue_open.png"  },
      pink:  { closed: "stage1/pink_closed.png",  open: "stage1/pink_open.png"  },
      purple:{ closed: "stage1/purple_closed.png",open: "stage1/purple_open.png"}
    },
    macaron: {
      green: "stage1/macaron_green.png",
      blue:  "stage1/macaron_blue.png",
      pink:  "stage1/macaron_pink.png",
      purple:"stage1/macaron_purple.png"
    }
  };

  const DAY_MS = 24*60*60*1000;
  const LIFE_MS = 3*DAY_MS;

  // 誕生は時間経過で起こす（3分）
  const HATCH_MS = 3*60*1000;

  // 時間設定（テスト用に短縮もできる）
// URLに ?fast=1 を付けると一時的にテストモードになります
const url = new URL(location.href);
const TIME_MODE_KEY = "care3days_timeMode";
const baseMode = (url.searchParams.get("fast") === "1") ? "fast" : ((localStorage.getItem(TIME_MODE_KEY) === "fast") ? "fast" : "normal");

function inferFastFromSave(s){
  try{
    if(s && s.life && s.life.bornAt && s.life.deathAt){
      const d = s.life.deathAt - s.life.bornAt;
      if(d > 0 && d < 10*60*1000) return true;
    }
    if(s && s.story && s.story.hatchAt && s.story.arrivalAt){
      const d = s.story.hatchAt - s.story.arrivalAt;
      if(d > 0 && d < 60*1000) return true;
    }
  }catch(e){}
  return baseMode === "fast";
}

function isFast(s){
  const obj = s || save;
  if(obj && obj.config && typeof obj.config.fast === "boolean") return obj.config.fast;
  return baseMode === "fast";
}
function hatchMsEff(s){ return isFast(s) ? 12*1000 : HATCH_MS; }
function lifeMsEff(s){ return isFast(s) ? 90*1000 : LIFE_MS; }
function dayMsEff(s){ return lifeMsEff(s) / 3; }

  const isObserveMode = !!url.searchParams.get("observe") && !!url.searchParams.get("data");

  const $ = (id) => document.getElementById(id);
  const screens = {
    intro: $("scr_intro"),
    search: $("scr_search"),
    arrival: $("scr_arrival"),
    care: $("scr_care"),
    end: $("scr_end"),
    logs: $("scr_logs"),
    observe: $("scr_observe")
  };

  const modeLabel = $("modeLabel");
  const modeMeta = $("modeMeta");
  const subline = $("subline");

  const overlay = $("overlay");
  const modalTitle = $("modalTitle");
  const modalNote = $("modalNote");
  const modalBtns = $("modalBtns");

  let save = null;
  let tickTimer = null;

  function clamp(n, a, b){ return Math.max(a, Math.min(b, n)); }
  function rnd(a,b){ return a + Math.random()*(b-a); }
  function nowMs(){ return Date.now(); }

  // シッター中は時間が停止する（内部時間だけ止める）
  function effectiveNow(s){
    if(!s) return nowMs();
    const baseNow = nowMs();
    const pauseExtra = s.sitter.on ? (baseNow - s.sitter.onSince) : 0;
    return baseNow - s.sitter.pausedTotal - pauseExtra;
  }

  function dayIndex(s){
    if(!s || !s.life.bornAt) return 0;
    const t = effectiveNow(s) - s.life.bornAt;
    const d = Math.floor(t / dayMsEff(s)) + 1;
    return clamp(d, 1, 3);
  }

  function showScreen(name){
    Object.values(screens).filter(Boolean).forEach(el => el.classList.remove("active"));
    (screens[name] || null) && screens[name].classList.add("active");
  }

  function setModePill(){
    if(isObserveMode){
      modeLabel.textContent = "観察";
      modeMeta.textContent = "操作不可";
      subline.textContent = "ログとハート推移のみ";
    }else{
      modeLabel.textContent = "プレイ";
      modeMeta.textContent = "ローカル保存";
      subline.textContent = "記録だけが残る";
    }
  }

  function safeJSONParse(str, fallback){
    try{ return JSON.parse(str); }catch(e){ return fallback; }
  }

  function emptyDay(d){
    return {
      day: d,
      heartStart: null,
      heartEnd: null,
      sitterMs: 0,
      careCounts: { food:0, outing:0, mini:0, clean:0, drink:0, macaron:0 },
      choices: { food:[], outing:[], mini:[], clean:[] }
    };
  }

  function genId(){
    return "p" + Math.random().toString(36).slice(2,10) + "-" + Date.now().toString(36);
  }

  function newSave(){
    const id = genId();
    const t = nowMs();
    return {
      v: 2,
      config: { fast: (baseMode === 'fast'), timeMode: (baseMode === 'fast' ? 'fast' : 'normal') },
      id,
      playerName: "",
      startedAt: t,
      story: {
        chosenColor: null,
      twinColor: null,
        foundAt: null,
        arrivalAt: null,
        hatchAt: null,
        hatched: false,
        _targetTile: null,
        _revealed: []
      },
      life: {
        bornAt: null,
        deathAt: null,
        endedAt: null,
        isEnded: false,
        revivedUntil: null,
        uncanny: false,
        _handledEnd: false
      },
      stats: {
        hunger: 30,
        waste: 20,
        mood: 70,
        hearts: 55
      },
      sitter: {
        on: false,
        onSince: null,
        pausedTotal: 0,
        usedTotal: 0
      },
      items: {
        drink: 2,
        macaron: 1
      },
      logs: {
        day: { "1": emptyDay(1), "2": emptyDay(2), "3": emptyDay(3) },
        events: []
      },
      _lastEff: t,
      _prevDay: 0
    };
  }

  function loadSave(){
    const raw = localStorage.getItem(APP_KEY);
    if(raw){
      const parsed = safeJSONParse(raw, null);
      if(parsed && (parsed.v === 2)) return parsed;
    }
    return newSave();
  }

  function saveNow(){
    localStorage.setItem(APP_KEY, JSON.stringify(save));
  }

  function resetAll(){
    localStorage.removeItem(APP_KEY);
    save = newSave();
    saveNow();
  }

  function addEvent(type, detail){
    const t = effectiveNow(save);
    const d = dayIndex(save) || 1;
    save.logs.events.push({ t, day:d, type, detail });

    const dayObj = save.logs.day[String(d)] || null;
    if(dayObj){
      if(type === "food"){ dayObj.careCounts.food++; dayObj.choices.food.push(detail.choice); }
      if(type === "outing"){ dayObj.careCounts.outing++; dayObj.choices.outing.push(detail.choice); }
      if(type === "mini"){ dayObj.careCounts.mini++; dayObj.choices.mini.push(detail.choice); }
      if(type === "clean"){ dayObj.careCounts.clean++; dayObj.choices.clean.push(detail.choice); }
      if(type === "drink"){ dayObj.careCounts.drink++; }
      if(type === "macaron"){ dayObj.careCounts.macaron++; }
      if(type === "sitterOn" || type === "sitterOff"){
        // sitterMs は切り替え時に更新
      }
    }
  }

  function formatTime(ms){
    const dt = new Date(ms);
    const hh = String(dt.getHours()).padStart(2,"0");
    const mm = String(dt.getMinutes()).padStart(2,"0");
    return `${hh}:${mm}`;
  }

  function ensureDayHearts(){
    if(!save.life.bornAt) return;
    const d = dayIndex(save);
    const dayObj = save.logs.day[String(d)];
    if(dayObj && dayObj.heartStart == null){
      dayObj.heartStart = save.stats.hearts;
    }
  }

  function finalizeDayIfNeeded(prevDay, nextDay){
    if(prevDay === 0 || prevDay === nextDay) return;
    const prevObj = save.logs.day[String(prevDay)];
    if(prevObj && prevObj.heartEnd == null){
      prevObj.heartEnd = save.stats.hearts;
    }
    const nextObj = save.logs.day[String(nextDay)];
    if(nextObj && nextObj.heartStart == null){
      nextObj.heartStart = save.stats.hearts;
    }
  }

  function finalizeAllDaysAtEnd(){
    for(let d=1; d<=3; d++){
      const obj = save.logs.day[String(d)];
      if(obj.heartStart == null && d===1) obj.heartStart = save.stats.hearts;
      if(obj.heartEnd == null) obj.heartEnd = save.stats.hearts;
    }
  }

  // 観察URL（ログとハート推移だけ）
  function buildSharePayload(s){
    const out = {
      v: 2,
      id: s.id,
      createdAt: nowMs(),
      chosenColor: s.story.chosenColor,
      twinColor: s.story.twinColor,
      endedAt: s.life.endedAt || null,
      days: []
    };
    for(let d=1; d<=3; d++){
      const obj = s.logs.day[String(d)];
      const heartStart = obj.heartStart;
      const heartEnd = (obj.heartEnd != null) ? obj.heartEnd : ((d===dayIndex(s)) ? s.stats.hearts : null);
      out.days.push({
        day: d,
        heartStart,
        heartEnd,
        heartDelta: (heartStart!=null && heartEnd!=null) ? (heartEnd-heartStart) : null,
        sitterMs: obj.sitterMs,
        careCounts: obj.careCounts,
        choices: obj.choices,
        events: s.logs.events.filter(e => e.day===d).slice(0,120).map(e => ({ t:e.t, type:e.type, detail:e.detail }))
      });
    }
    return out;
  }
  function encodeShare(payload){
    const json = JSON.stringify(payload);
    return btoa(unescape(encodeURIComponent(json)));
  }
  function decodeShare(b64){
    const json = decodeURIComponent(escape(atob(b64)));
    return safeJSONParse(json, null);
  }
  function shareUrlForCurrentSave(){
    ensureTwinColors();
    const payload = buildSharePayload(save);
    const data = encodeShare(payload);
    const u = new URL(location.href);
    u.searchParams.set("observe", payload.id);
    u.searchParams.set("data", data);
    u.searchParams.delete("fast");
    return u.toString();
  }

  function copyToClipboard(text){
    if(navigator.clipboard && navigator.clipboard.writeText){
      navigator.clipboard.writeText(text).catch(()=>fallbackCopy(text));
    }else{
      fallbackCopy(text);
    }
  }
  function fallbackCopy(text){
    const ta = document.createElement("textarea");
    ta.value = text;
    ta.style.position="fixed";
    ta.style.opacity="0";
    document.body.appendChild(ta);
    ta.focus();
    ta.select();
    try{ document.execCommand("copy"); }catch(e){}
    document.body.removeChild(ta);
  }

  function prettyColor(c){
    if(c==="green") return "みどり";
    if(c==="blue") return "あお";
    if(c==="pink") return "もも";
    if(c==="purple") return "むらさき";
    return c;
  }

  function hashStr(s){
    let h = 0;
    for(let i=0;i<(s||"" ).length;i++){ h = (h*31 + s.charCodeAt(i))>>>0; }
    return h>>>0;
  }

  function pickTwinColor(primary){
    const colors = ["green","blue","pink","purple"];
    const opts = colors.filter(x => x !== primary);
    return opts[Math.floor(Math.random()*opts.length)] || "blue";
  }

  function ensureTwinColors(){
    if(!save || !save.story || !save.story.chosenColor) return;
    const a = save.story.chosenColor;
    if(!save.story.twinColor || save.story.twinColor === a){
      save.story.twinColor = pickTwinColor(a);
      saveNow();
    }
  }

function normalizeSaveConfig(){
  if(!save) return;
  if(!save.config) save.config = {};
  if(typeof save.config.fast !== "boolean") save.config.fast = inferFastFromSave(save);
  if(!save.config.timeMode) save.config.timeMode = save.config.fast ? "fast" : "normal";
  // 古い保存データでも2体が同色にならないように
  ensureTwinColors();
  // 設定の既定値を端末側にも残す（次回の初期値）
  try{ localStorage.setItem(TIME_MODE_KEY, save.config.fast ? "fast" : "normal"); }catch(e){}
}

  function wireTimeModeSelect(){
  const sel = $('timeMode');
  const note = $('timeModeNote');
  if(!sel || !note) return;

  // 進行している場合は、途中で切り替えると時刻がずれるので無効化
  const progressed = !!(save && (save.story.foundAt || save.story.arrivalAt || save.life.bornAt || save.life.isEnded));
  sel.disabled = progressed;

  const curMode = (save && save.config && save.config.fast) ? 'fast' : 'normal';
  sel.value = curMode;

  const setNote = (mode) => {
    if(progressed){
      note.textContent = '途中からは変えられません。新しく始めるときに設定できます。';
    }else{
      note.textContent = (mode==='fast') ? 'テスト用：誕生と3日間が短く進みます。' : '通常：誕生は3分、寿命は3日です。';
    }
  };
  setNote(sel.value);

  sel.onchange = () => {
    const mode = sel.value;
    try{ localStorage.setItem(TIME_MODE_KEY, mode); }catch(e){}
    if(save && !progressed){
      if(!save.config) save.config = {};
      save.config.fast = (mode === 'fast');
      save.config.timeMode = mode;
      saveNow();
    }
    setNote(mode);
  };
}

function renderOnboarding(){
    showScreen("intro");

    const box = $("charChoices");
    const preview = $("charPreview");
    if(!box || !preview) return;

    box.innerHTML = "";
    const colors = ["green","blue","pink","purple"];
    const desc = {
      green: "風が通るみたいに、軽い。",
      blue: "静かな場所で、目が合う。",
      pink: "少しだけ、あたたかい。",
      purple: "夢の端っこに触れる。"
    };

    const selected = save.story.chosenColor || "";
    const fallback = selected || "green";
    preview.src = ASSETS.char[fallback].open;

    colors.forEach(c => {
      const btn = document.createElement("button");
      btn.className = "choice" + (c === selected ? " selected" : "");
      btn.type="button";
      btn.innerHTML = `
        <img src="${ASSETS.char[c].open}" alt="${c}">
        <div class="ctext">
          <div class="cname">${prettyColor(c)}</div>
          <div class="cdesc">${desc[c]}</div>
        </div>
        <div class="tiny">選ぶ</div>
      `;

      btn.addEventListener("mouseenter", () => { preview.src = ASSETS.char[c].open; });
      btn.addEventListener("mouseleave", () => {
        const cur = save.story.chosenColor || fallback;
        preview.src = ASSETS.char[cur].open;
      });

      btn.addEventListener("click", () => {
        save.story.chosenColor = c;
        saveNow();

        // 見た目だけ更新（全部作り直さずに選択状態だけ更新）
        [...box.querySelectorAll(".choice")].forEach(el => el.classList.remove("selected"));
        btn.classList.add("selected");
        preview.src = ASSETS.char[c].open;
        updateStartButton();
      });

      box.appendChild(btn);
    });

    // 既に名前があるなら入力欄に反映
    const pn = $("playerName");
    if(pn && save.playerName && !pn.value) pn.value = save.playerName;

    wireTimeModeSelect();

    updateResumeBox();
    updateStartButton();
  }

  function updateStartButton(){
    const name = (($("playerName") && $("playerName").value) || "").trim();
    const hasName = name.length > 0;
    const hasChar = !!save.story.chosenColor;

    const btn = $("btn_start");
    if(btn) btn.disabled = !(hasName && hasChar);

    const tip = $("introNeed");
    if(!tip) return;

    if(hasName && hasChar) tip.textContent = "";
    else if(!hasName && !hasChar) tip.textContent = "名前と相棒を決めると、はじめられます。";
    else if(!hasName) tip.textContent = "呼ばれたい名前を入れると、はじめられます。";
    else tip.textContent = "相棒を選ぶと、はじめられます。";
  }


  function updateResumeBox(){
    const box = $("resumeBox");
    const meta = $("resumeMeta");
    const btn = $("btn_resume");
    if(!box || !meta || !btn) return;

    const hasProgress = !!(save && (save.life.isEnded || save.life.bornAt || save.story.arrivalAt || save.story.foundAt));
    const ready = !!(save && save.playerName && save.story.chosenColor && hasProgress);

    box.style.display = ready ? "block" : "none";
    if(!ready) return;

    let label = "";
    if(save.life.isEnded) label = "3日間が終わっています";
    else if(save.life.bornAt) label = `いまは Day ${dayIndex(save)}`;
    else if(save.story.arrivalAt) label = "マカロンが到着している";
    else label = "探している途中";
    meta.textContent = label;

    btn.onclick = () => { resumeToProgress(); };
  }

  function startFromOnboarding(){
    const name = (($('playerName') && $('playerName').value) || '').trim();
    const chosen = save.story.chosenColor;
    const modeSel = ($('timeMode') && $('timeMode').value) ? $('timeMode').value : (save.config && save.config.fast ? 'fast' : 'normal');

    if(!name || !chosen) return;

    // 一度きれいにしてから、名前と相棒だけ残す
    resetAll();
    // 時間設定を反映（新しく始めるときだけ）
    if(!save.config) save.config = {};
    save.config.fast = (modeSel === "fast");
    save.config.timeMode = modeSel;
    try{ localStorage.setItem(TIME_MODE_KEY, modeSel); }catch(e){}

    save.playerName = name;
    save.story.chosenColor = chosen;
    save.story.twinColor = pickTwinColor(chosen);

    // 探しもの探しへ
    resetSearch();
    buildMap();

    subline.textContent = name ? `○○（${name}）の記録` : "記録だけが残る";
    saveNow();
    showScreen("search");
  }

  function resetSearch(){
    save.story.foundAt = null;
    save.story.arrivalAt = null;
    save.story.hatchAt = null;
    save.story.hatched = false;
    save.story._targetTile = null;
    save.story._revealed = [];
    saveNow();
  }

  function buildMap(){
    const grid = $("mapGrid");
    grid.innerHTML = "";
    const N = 12;

    if(!save.story._targetTile){
      save.story._targetTile = Math.floor(Math.random()*N);
      save.story._revealed = [];
      saveNow();
    }

    const chosen = save.story.chosenColor || "blue";
    const macImg = ASSETS.macaron[chosen];

    for(let i=0;i<N;i++){
      const tile = document.createElement("button");
      tile.className = "tile";
      tile.type="button";
      tile.innerHTML = `<div class="spark"></div><span>……</span><img class="foundImg" alt="macaron">`;
      const img = tile.querySelector(".foundImg");
      img.src = macImg;

      if(save.story._revealed.includes(i)){
        tile.classList.add("revealed");
        tile.querySelector("span").textContent = " ";
        if(i === save.story._targetTile){
          tile.classList.add("found");
        }
      }

      tile.addEventListener("click", () => {
        if(save.story.foundAt) return;

        if(!save.story._revealed.includes(i)) save.story._revealed.push(i);
        tile.classList.add("revealed");
        tile.querySelector("span").textContent = " ";

        if(i === save.story._targetTile){
          tile.classList.add("found");
          save.story.foundAt = nowMs();

          // 見つけた瞬間に「到着」させる（誕生はそこから3分後）
          save.story.arrivalAt = effectiveNow(save);
          save.story.hatchAt = save.story.arrivalAt + hatchMsEff(save);
          save.story.hatched = false;

          $("searchNote").textContent = "見つかった。近づくと、温かい。";
          addEvent("found", { where: i, colorA: save.story.chosenColor, colorB: save.story.twinColor });
          saveNow();

          setTimeout(() => showArrival(), 650);
        }else{
          $("searchNote").textContent = "そこには、光の粒だけが残っている。";
          saveNow();
        }
      });

      grid.appendChild(tile);
    }
  }

  function showArrival(){
    showScreen("arrival");
    const c = save.story.chosenColor || "green";
    $("arrivalImg").src = ASSETS.macaron[c];
  }

  function maybeHatch(){
    if(save.story.hatched) return;
    if(!save.story.hatchAt) return;

    const t = effectiveNow(save);
    if(t >= save.story.hatchAt){
      save.story.hatched = true;

      const bornAt = save.story.hatchAt;
      save.life.bornAt = bornAt;
      save.life.deathAt = bornAt + lifeMsEff(save);
      save.life.isEnded = false;
      save.life.endedAt = null;
      save.life.revivedUntil = null;
      save.life.uncanny = false;
      save.life._handledEnd = false;

      save.logs.day["1"] = emptyDay(1);
      save.logs.day["2"] = emptyDay(2);
      save.logs.day["3"] = emptyDay(3);
      save.logs.events = [];
      save.logs.day["1"].heartStart = save.stats.hearts;

      addEvent("hatch", { colorA: save.story.chosenColor, colorB: save.story.twinColor });
      saveNow();
      showCare();
    }
  }

  function openChoiceModal(title, note, choices){
    modalTitle.textContent = title;
    modalNote.textContent = note;
    modalBtns.innerHTML = "";
    choices.forEach(ch => {
      const b = document.createElement("button");
      b.className = "btn " + (ch.style || "");
      b.textContent = ch.label;
      b.addEventListener("click", () => {
        closeModal();
        ch.onPick();
      });
      modalBtns.appendChild(b);
    });
    overlay.classList.add("on");
  }
  function closeModal(){ overlay.classList.remove("on"); }

  function applySoftImpact({ hunger=0, waste=0, mood=0, hearts=0 }){
    save.stats.hunger = clamp(save.stats.hunger + hunger, 0, 100);
    save.stats.waste  = clamp(save.stats.waste  + waste, 0, 100);

    const moodCap = save.life.uncanny ? 60 : 100;
    save.stats.mood = clamp(save.stats.mood + mood, 0, moodCap);

    const heartCap = save.life.uncanny ? Math.min(save.stats.hearts, 70) : 100;
    save.stats.hearts = clamp(save.stats.hearts + hearts, 0, heartCap);
  }

  function blockedByEnd(){ return save.life.isEnded; }

  // お世話（2択）
  function actFood(){
    if(blockedByEnd()) return;
    openChoiceModal(
      "食事",
      "軽くするか、しっかりにするか。理由は表示されない。",
      [
        { label:"軽い食事", style:"secondary", onPick: () => {
          applySoftImpact({ hunger: -18 + rnd(-2,2), waste: +10 + rnd(-2,2), mood: +4 + rnd(-1,1), hearts: +1 });
          addEvent("food", { choice: "light" });
          saveNow();
        }},
        { label:"しっかりした食事", onPick: () => {
          applySoftImpact({ hunger: -30 + rnd(-3,3), waste: +16 + rnd(-3,3), mood: +2 + rnd(-2,2), hearts: +1 });
          addEvent("food", { choice: "hearty" });
          saveNow();
        }}
      ]
    );
  }

  function actOuting(){
    if(blockedByEnd()) return;
    openChoiceModal(
      "お出かけ",
      "外へ出るか、家で過ごすか。",
      [
        { label:"外に出る", onPick: () => {
          applySoftImpact({ hunger: +8 + rnd(-2,2), waste: +8 + rnd(-2,2), mood: +10 + rnd(-2,2), hearts: +2 });
          addEvent("outing", { choice: "outside" });
          saveNow();
        }},
        { label:"家で過ごす", style:"secondary", onPick: () => {
          applySoftImpact({ hunger: +4 + rnd(-2,2), waste: +4 + rnd(-2,2), mood: +6 + rnd(-2,2), hearts: +1 });
          addEvent("outing", { choice: "home" });
          saveNow();
        }}
      ]
    );
  }

  function actMini(){
    if(blockedByEnd()) return;
    const prompts = [
      { q:"光の粒を、集める？ 眺める？", a:"集める", b:"眺める", ka:"collect", kb:"watch" },
      { q:"近づく？ 少し離れる？", a:"近づく", b:"離れる", ka:"near", kb:"far" },
      { q:"触れる？ 見守る？", a:"触れる", b:"見守る", ka:"touch", kb:"watch2" }
    ];
    const p = prompts[Math.floor(Math.random()*prompts.length)];
    openChoiceModal(
      "2択ミニゲーム",
      p.q,
      [
        { label:p.a, onPick: () => {
          applySoftImpact({ mood: +6 + rnd(-3,3), hearts: +1 });
          addEvent("mini", { choice: p.ka });
          saveNow();
        }},
        { label:p.b, style:"secondary", onPick: () => {
          applySoftImpact({ mood: +5 + rnd(-3,3), hearts: +1 });
          addEvent("mini", { choice: p.kb });
          saveNow();
        }}
      ]
    );
  }

  function actClean(){
    if(blockedByEnd()) return;
    openCleanMini();
  }

  // 排泄除去の小さなミニゲーム（クリックで消す）
  function openCleanMini(){
    modalTitle.textContent = "排泄除去";
    modalNote.textContent = "画面の中に出る汚れをクリックして消す。成功しても評価は出ない。";
    modalBtns.innerHTML = "";

    const area = document.createElement("div");
    area.style.position = "relative";
    area.style.height = "220px";
    area.style.borderRadius = "16px";
    area.style.border = "1px solid rgba(15,23,42,.14)";
    area.style.background = "rgba(255,255,255,.75)";
    area.style.overflow = "hidden";
    area.style.marginTop = "12px";

    const status = document.createElement("div");
    status.className = "tiny";
    status.style.marginTop = "10px";
    status.textContent = " ";

    const poopCount = 7;
    let removed = 0;
    let ended = false;

    function makeBlob(){
      const b = document.createElement("button");
      b.type="button";
      b.style.position="absolute";
      b.style.width = (18 + Math.random()*22) + "px";
      b.style.height = (14 + Math.random()*16) + "px";
      b.style.borderRadius = "12px";
      b.style.border = "1px solid rgba(15,23,42,.16)";
      b.style.background = "linear-gradient(180deg, rgba(15,23,42,.12), rgba(15,23,42,.28))";
      b.style.left = (8 + Math.random()*84) + "%";
      b.style.top = (8 + Math.random()*74) + "%";
      b.style.transform = `rotate(${Math.random()*22-11}deg)`;
      b.style.cursor = "pointer";
      b.style.boxShadow = "0 10px 18px rgba(15,23,42,.10)";
      b.addEventListener("click", () => {
        if(ended) return;
        b.remove();
        removed++;
        if(removed >= poopCount){
          finish(true);
        }
      });
      return b;
    }

    for(let i=0;i<poopCount;i++){
      area.appendChild(makeBlob());
    }

    const timer = document.createElement("div");
    timer.className = "tiny";
    timer.style.marginTop = "8px";
    let left = isFast(save) ? 6 : 12;

    const iv = setInterval(() => {
      if(ended) return;
      left--;
      if(left<=0){
        finish(false);
      }
    }, 1000);

    function finish(success){
      if(ended) return;
      ended = true;
      clearInterval(iv);

      if(success){
        applySoftImpact({ waste: -28 + rnd(-4,4), mood: +6 + rnd(-2,2), hearts: +1 });
        addEvent("clean", { choice: "done" });
      }else{
        applySoftImpact({ waste: -12 + rnd(-3,3), mood: +1 + rnd(-2,2), hearts: 0 });
        addEvent("clean", { choice: "partial" });
      }
      saveNow();
      closeModal();
    }

    const body = $("modalBody");
    body.innerHTML = "";
    body.appendChild(status);
    body.appendChild(area);
    body.appendChild(timer);

    overlay.classList.add("on");
  }

  // 生存中アイテム
  function actDrink(){
    if(blockedByEnd()) return;
    if(save.items.drink <= 0) return;
    openChoiceModal(
      "ドリンク",
      "生存中に使える。少しだけ戻る感じがする。理由は説明されない。",
      [
        { label:"飲ませる", onPick: () => {
          save.items.drink--;
          applySoftImpact({ hunger: -16 + rnd(-3,3), waste: -10 + rnd(-3,3), mood: +8 + rnd(-2,2), hearts: +1 });

          // 少しだけ寿命を延ばす（内部時間の調整）
          save.life.deathAt += (isFast(save) ? 6*1000 : 2*60*60*1000);

          addEvent("drink", {});
          saveNow();
        }},
        { label:"やめておく", style:"secondary", onPick: () => {} }
      ]
    );
  }

  // 死後アイテム
  function actMacaron(){
    if(!save.life.isEnded) return;
    if(save.items.macaron <= 0) return;

    openChoiceModal(
      "マカロン",
      "死後に使える。一時的に戻るが、完全には戻らない。",
      [
        { label:"使う", onPick: () => {
          save.items.macaron--;
          const t = effectiveNow(save);
          save.life.isEnded = false;
          save.life.endedAt = null;
          save.life.revivedUntil = t + (isFast(save) ? 22*1000 : 12*60*60*1000);
          save.life.uncanny = true;

          // どこか違和感のある復活
          save.stats.hunger = clamp(save.stats.hunger, 35, 85);
          save.stats.waste = clamp(save.stats.waste, 25, 90);
          save.stats.mood = clamp(save.stats.mood, 25, 55);

          addEvent("macaron", {});
          saveNow();
          showCare();
        }},
        { label:"やめておく", style:"secondary", onPick: () => {} }
      ]
    );
  }

  function maybeEnd(){
    if(!save.life.bornAt) return;

    const t = effectiveNow(save);

    if(save.life.revivedUntil && t >= save.life.revivedUntil){
      save.life.revivedUntil = null;
      save.life.isEnded = true;
      save.life.endedAt = t;
    }

    if(!save.life.revivedUntil && !save.life.isEnded){
      if(t >= save.life.deathAt){
        save.life.isEnded = true;
        save.life.endedAt = t;
      }
    }

    if(save.life.isEnded && !save.life._handledEnd){
      save.life._handledEnd = true;
      finalizeAllDaysAtEnd();
      addEvent("end", {});
      saveNow();
      showEnd();
    }
  }

  // 時間経過による状態変化（表示はしない）
  function stepByTime(dtMs){
    const dt = dtMs / 1000;

    const hungerRate = 100 / (isFast(save) ? 35 : (12*60*60));
    const wasteRate  = 100 / (isFast(save) ? 25 : (8*60*60));

    let hungerAdd = dt * hungerRate;
    let wasteAdd  = dt * wasteRate;

    if(save.life.uncanny){
      hungerAdd *= 1.25;
      wasteAdd  *= 1.25;
    }

    save.stats.hunger = clamp(save.stats.hunger + hungerAdd, 0, 100);
    save.stats.waste  = clamp(save.stats.waste  + wasteAdd, 0, 100);

    let moodDrop = 0;
    if(save.stats.hunger > 70) moodDrop += (dt * 0.020);
    if(save.stats.waste > 70) moodDrop += (dt * 0.024);
    if(save.stats.hunger > 85) moodDrop += (dt * 0.028);
    if(save.stats.waste > 85) moodDrop += (dt * 0.032);

    let moodRise = 0;
    if(save.stats.hunger < 45 && save.stats.waste < 45){
      moodRise += dt * 0.010;
    }

    const moodCap = save.life.uncanny ? 60 : 100;
    save.stats.mood = clamp(save.stats.mood - moodDrop + moodRise, 0, moodCap);

    if(save.stats.hunger > 85 || save.stats.waste > 85){
      save.stats.hearts = clamp(save.stats.hearts - dt*0.0012, 0, save.life.uncanny ? Math.min(save.stats.hearts,70) : 100);
    }else if(save.stats.mood > 75 && save.stats.hunger < 55 && save.stats.waste < 55){
      save.stats.hearts = clamp(save.stats.hearts + dt*0.0006, 0, save.life.uncanny ? Math.min(save.stats.hearts,70) : 100);
    }
  }

  // 状態はラベル表示しない。表情と動きだけで見せる
  function stateKind(){
    const { hunger, waste, mood } = save.stats;
    const bad = (hunger > 80) + (waste > 80);
    if(save.life.isEnded) return "ended";
    if(bad >= 2 || mood < 22) return "cry";
    if(bad >= 1 || mood < 45) return "sad";
    if(mood > 72 && hunger < 60 && waste < 60) return "happy";
    return "ok";
  }


  // 生まれた直後は小さく、3日で少しずつ大きくなる（カウントダウン表示はしない）
// 左＝ユーザーが選んだ子、右＝生まれてきた子（最初は右が少し小さい）
function growthScalesLive(){
  if(!save.life.bornAt) return { a:0.50, b:0.36, p:0 };
  const eff = effectiveNow(save);

  // 終了後は、その時点で止める
  const endT = save.life.isEnded ? (save.life.endedAt || save.life.deathAt) : save.life.deathAt;
  const denom = Math.max(1, endT - save.life.bornAt);
  const t = clamp(eff - save.life.bornAt, 0, denom);
  const p = t / denom;

  const aMin = 0.50;
  const aMax = 1.05;
  const bMin = 0.36;
  const bMax = 1.05;

  return {
    a: aMin + (aMax - aMin) * p,
    b: bMin + (bMax - bMin) * p,
    p
  };
}

function separationFromScale(sc){
    // 小さいほど離れて見え、大きいほど少し寄り添う
    const p = clamp((sc-0.50)/(1.05-0.50), 0, 1);
    const sep = 96 - 38*p; // px
    return `${sep.toFixed(1)}px`;
  }

  // 状態はラベル表示しない。表情と動きだけで見せる
  function renderCare(){
    ensureTwinColors();
    const a = save.story.chosenColor || "green";
    const b = save.story.twinColor || pickTwinColor(a);

    $("btn_drink").disabled = save.life.isEnded || save.items.drink<=0;
    $("btn_macaron").disabled = (!save.life.isEnded) || save.items.macaron<=0;

    const kind = stateKind();

    const pair = $("charPair");
    const imgA = $("charImg");
    const imgB = $("charImg2");
    const tear = $("tear");
    const poops = [ $("po1"), $("po2"), $("po3"), $("po4") ];
    const useOpenA = (kind === "happy") || (kind === "cry" && (a==="blue" || a==="pink"));
    const useOpenB = (kind === "happy") || (kind === "cry" && (b==="blue" || b==="pink"));
    const srcA = useOpenA ? ASSETS.char[a].open : ASSETS.char[a].closed;
    const srcB = useOpenB ? ASSETS.char[b].open : ASSETS.char[b].closed;
    imgA.src = srcA;
    imgB.src = srcB;

    // 成長反映
    const gs = growthScalesLive();
    pair.style.setProperty("--growA", gs.a.toFixed(3));
    pair.style.setProperty("--growB", gs.b.toFixed(3));
    const scMean = (gs.a + gs.b) / 2;
    pair.style.setProperty("--sep", separationFromScale(scMean));

    // クラス整理
    pair.classList.remove("k-ok","k-happy","k-sad","k-cry","k-ended","uncanny");
    tear.classList.remove("on");

    if(kind === "happy"){
      pair.classList.add("k-happy");
    }else if(kind === "ok"){
      pair.classList.add("k-ok");
    }else if(kind === "sad"){
      pair.classList.add("k-sad");
      tear.classList.add("on");
    }else if(kind === "cry"){
      pair.classList.add("k-cry");
      tear.classList.add("on");
    }else if(kind === "ended"){
      pair.classList.add("k-ended");
    }

    if(save.life.uncanny && !save.life.isEnded){
      pair.classList.add("uncanny");
    }

    const dirty = save.stats.waste > 70;
    poops.forEach(p => p.classList.toggle("on", dirty));

    const h = save.stats.hearts;
    const level = Math.round(clamp(h,0,100)/20);
    [ $("h1"),$("h2"),$("h3"),$("h4"),$("h5") ].forEach((el,i)=>{
      el.classList.toggle("on", i < level);
    });

    const tgl = $("toggle_sitter");
    tgl.classList.toggle("on", save.sitter.on);
    tgl.setAttribute("aria-checked", save.sitter.on ? "true":"false");
    $("sitterNote").textContent = save.sitter.on ? "止まっている" : "時間は止まる";

    $("endNote").style.display = save.life.isEnded ? "block" : "none";
    $("shareBox").style.display = "flex";

    const hint = $("careHint");
    if(save.life.uncanny && !save.life.isEnded){
      hint.textContent = "戻ってきた。でも、どこか違う気がする。";
    }else{
      hint.textContent = "言葉ではわからない。表情と動きだけが変わる。";
    }
  }
  function showCare(){
    ensureTwinColors();
    showScreen("care");
    renderCare();
    const shareUrl = shareUrlForCurrentSave();
    $("shareUrl").value = shareUrl;
    $("shareUrl2").value = shareUrl;
  }

  function showEnd(){
    showScreen("end");
    const shareUrl = shareUrlForCurrentSave();
    $("shareUrl").value = shareUrl;
    $("shareUrl2").value = shareUrl;
  }

  function resumeToProgress(){
    if(!save.playerName || !save.story.chosenColor){
      renderOnboarding();
      return;
    }
    if(save.life.isEnded){
      showEnd();
    }else if(save.life.bornAt){
      showCare();
    }else if(save.story.arrivalAt){
      showArrival();
    }else{
      buildMap();
      showScreen("search");
    }
  }

  function msToHuman(ms){
    if(!ms || ms<=0) return "0分";
    const m = Math.round(ms/60000);
    if(m < 60) return `${m}分`;
    const h = Math.floor(m/60);
    const mm = m%60;
    return `${h}時間${mm}分`;
  }

  function summarizeChoices(choices){
    const out = [];
    const mapCount = (arr) => arr.reduce((acc,x)=>{ acc[x]=(acc[x]||0)+1; return acc; }, {});
    const tFood = mapCount(choices.food || []);
    const tOut = mapCount(choices.outing || []);
    const tMini = mapCount(choices.mini || []);
    const tClean = mapCount(choices.clean || []);

    if(Object.keys(tFood).length){
      out.push(`食事の選択: ${Object.entries(tFood).map(([k,v])=>`${foodLabel(k)}×${v}`).join(" / ")}`);
    }
    if(Object.keys(tOut).length){
      out.push(`お出かけの選択: ${Object.entries(tOut).map(([k,v])=>`${outingLabel(k)}×${v}`).join(" / ")}`);
    }
    if(Object.keys(tMini).length){
      out.push(`ミニゲームの選択: ${Object.entries(tMini).map(([k,v])=>`${miniLabel(k)}×${v}`).join(" / ")}`);
    }
    if(Object.keys(tClean).length){
      out.push(`排泄除去: ${Object.entries(tClean).map(([k,v])=>`${cleanLabel(k)}×${v}`).join(" / ")}`);
    }
    if(!out.length) out.push("選択: （記録なし）");
    return out;
  }
  function foodLabel(k){ return k==="light" ? "軽い" : (k==="hearty" ? "しっかり" : k); }
  function outingLabel(k){ return k==="outside" ? "外" : (k==="home" ? "家" : k); }
  function miniLabel(k){
    const m = { collect:"集める", watch:"眺める", near:"近づく", far:"離れる", touch:"触れる", watch2:"見守る" };
    return m[k] || k;
  }
  function cleanLabel(k){ return k==="done" ? "完了" : (k==="partial" ? "途中" : k); }

  function eventToText(e){
    const t = e.type;
    if(t==="chooseChar") return `キャラ選択（${prettyColor(e.detail.color)}）`;
    if(t==="found") return "見つけた";
    if(t==="hatch") return "誕生した";
    if(t==="food") return `食事（${foodLabel(e.detail.choice)}）`;
    if(t==="outing") return `お出かけ（${outingLabel(e.detail.choice)}）`;
    if(t==="mini") return `ミニ（${miniLabel(e.detail.choice)}）`;
    if(t==="clean") return `排泄除去（${cleanLabel(e.detail.choice)}）`;
    if(t==="drink") return "ドリンク";
    if(t==="macaron") return "マカロン";
    if(t==="sitterOn") return "シッターON";
    if(t==="sitterOff") return "シッターOFF";
    if(t==="end") return "終わった";
    return t;
  }

  function buildHeartSeriesFromSave(s){
    const arr = [];
    for(let d=1; d<=3; d++){
      const obj = s.logs.day[String(d)];
      const start = (obj && obj.heartStart!=null) ? obj.heartStart : null;
      const end = (obj && obj.heartEnd!=null) ? obj.heartEnd : ((d===dayIndex(s)) ? s.stats.hearts : null);
      if(end!=null) arr.push({ x:d, y:end });
      else if(start!=null) arr.push({ x:d, y:start });
      else arr.push({ x:d, y:null });
    }
    return arr;
  }

  function drawHeartChart(canvas, series){
    const ctx = canvas.getContext("2d");
    const W = canvas.width, H = canvas.height;
    ctx.clearRect(0,0,W,H);

    ctx.globalAlpha = 1;
    ctx.strokeStyle = "rgba(15,23,42,.18)";
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(36, 18);
    ctx.lineTo(36, H-28);
    ctx.lineTo(W-14, H-28);
    ctx.stroke();

    ctx.fillStyle = "rgba(15,23,42,.70)";
    ctx.font = "12px system-ui, sans-serif";
    for(let d=1; d<=3; d++){
      const x = mapX(d);
      ctx.fillText("D"+d, x-8, H-10);
    }

    const pts = series.filter(p => p.y!=null).map(p => ({ x:mapX(p.x), y:mapY(p.y) }));
    if(pts.length>=2){
      ctx.strokeStyle = "rgba(251,113,133,.88)";
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(pts[0].x, pts[0].y);
      for(let i=1;i<pts.length;i++) ctx.lineTo(pts[i].x, pts[i].y);
      ctx.stroke();
    }
    pts.forEach(p => {
      ctx.fillStyle = "rgba(251,113,133,.92)";
      ctx.beginPath();
      ctx.arc(p.x, p.y, 4, 0, Math.PI*2);
      ctx.fill();
    });

    function mapX(day){
      const left = 36, right = W-14;
      return left + (right-left)*( (day-1)/2 );
    }
    function mapY(val){
      const top = 18, bottom = H-28;
      const y = clamp(val,0,100);
      return bottom - (bottom-top)*(y/100);
    }
  }

  function showLogs(){
    showScreen("logs");
    const tabs = $("dayTabs");
    const box = $("logBox");
    tabs.innerHTML = "";
    box.innerHTML = "";

    for(let d=1; d<=3; d++){
      const b = document.createElement("button");
      b.className = "tab";
      b.type="button";
      b.textContent = `Day ${d}`;
      b.addEventListener("click", () => renderDay(d));
      tabs.appendChild(b);
    }
    renderDay(dayIndex(save) || 1);

    drawHeartChart($("heartChart"), buildHeartSeriesFromSave(save));

    const shareUrl = shareUrlForCurrentSave();
    $("shareUrl2").value = shareUrl;

    function renderDay(d){
      [...tabs.children].forEach((t,i)=>t.classList.toggle("active", i===d-1));
      box.innerHTML = "";

      const obj = save.logs.day[String(d)] || emptyDay(d);
      const heartStart = obj.heartStart;
      const heartEnd = (obj.heartEnd != null) ? obj.heartEnd : ((d===dayIndex(save)) ? save.stats.hearts : null);
      const delta = (heartStart!=null && heartEnd!=null) ? (heartEnd-heartStart) : null;

      const lines = [];
      lines.push(`Day ${d}`);
      if(heartStart!=null && heartEnd!=null){
        const sign = delta>=0 ? "+" : "";
        lines.push(`ハートの変化: ${sign}${Math.round(delta)}`);
      }else{
        lines.push(`ハートの変化: （未確定）`);
      }

      lines.push(`お世話: 食事${obj.careCounts.food} / お出かけ${obj.careCounts.outing} / ミニ${obj.careCounts.mini} / 排泄除去${obj.careCounts.clean}`);
      lines.push(`アイテム: ドリンク${obj.careCounts.drink} / マカロン${obj.careCounts.macaron}`);
      lines.push(`シッター: ${msToHuman(obj.sitterMs)}`);

      const cLines = summarizeChoices(obj.choices);
      cLines.forEach(s => lines.push(s));

      const evs = save.logs.events.filter(e => e.day===d);
      if(evs.length){
        lines.push(`出来事:`);
        evs.slice(0,120).forEach(e => {
          lines.push(`  ${formatTime(e.t)}  ${eventToText(e)}`);
        });
      }else{
        lines.push(`出来事: （なし）`);
      }

      lines.forEach(s => {
        const div = document.createElement("div");
        div.className = "logLine";
        div.textContent = s;
        box.appendChild(div);
      });
    }
  }

  // 観察モード
  function initObserve(){
    setModePill();
    showScreen("observe");

    const data = url.searchParams.get("data");
    const payload = decodeShare(data);
    if(!payload){
      $("logBoxObs").innerHTML = `<div class="logLine">読み込みに失敗しました。</div>`;
      return;
    }
    const colorA = payload.chosenColor || "green";
    const opts = ["green","blue","pink","purple"].filter(x => x !== colorA);
    const stableIdx = hashStr(payload.id || "") % Math.max(1, opts.length);
    const fallbackB = opts[stableIdx] || pickTwinColor(colorA);
    const colorB = (payload.twinColor && payload.twinColor !== colorA) ? payload.twinColor : fallbackB;
    $("charImgObs").src = ASSETS.char[colorA].open;
    $("charImgObs2").src = ASSETS.char[colorB].open;

    function setObsScale(day){
      const p = (day-1)/2;
      const sc = 0.50 + 0.55 * p;
      const sep = 96 - 38 * p;
      const pair = $("charPairObs");
      if(pair){
        pair.style.setProperty("--growA", sc.toFixed(3));
        const scB = 0.36 + (1.05-0.36)*p;
        pair.style.setProperty("--growB", scB.toFixed(3));
        pair.style.setProperty("--sep", `${sep.toFixed(1)}px`);
      }
    }

    const tabs = $("dayTabsObs");
    const box = $("logBoxObs");
    tabs.innerHTML = "";
    box.innerHTML = "";

    for(let d=1; d<=3; d++){
      const b = document.createElement("button");
      b.className = "tab";
      b.type="button";
      b.textContent = `Day ${d}`;
      b.addEventListener("click", () => render(d));
      tabs.appendChild(b);
    }
    render(1);

    const series = payload.days.map(x => ({ x:x.day, y:(x.heartEnd!=null ? x.heartEnd : x.heartStart) }));
    drawHeartChart($("heartChartObs"), series);

    function render(d){
      setObsScale(d);
      [...tabs.children].forEach((t,i)=>t.classList.toggle("active", i===d-1));
      box.innerHTML = "";

      const day = payload.days[d-1];
      if(!day){
        box.innerHTML = `<div class="logLine">（なし）</div>`;
        return;
      }
      const lines = [];
      lines.push(`Day ${day.day}`);
      if(day.heartDelta!=null){
        const sign = day.heartDelta>=0 ? "+" : "";
        lines.push(`ハートの変化: ${sign}${Math.round(day.heartDelta)}`);
      }else{
        lines.push(`ハートの変化: （未確定）`);
      }
      lines.push(`お世話: 食事${day.careCounts.food} / お出かけ${day.careCounts.outing} / ミニ${day.careCounts.mini} / 排泄除去${day.careCounts.clean}`);
      lines.push(`アイテム: ドリンク${day.careCounts.drink} / マカロン${day.careCounts.macaron}`);
      lines.push(`シッター: ${msToHuman(day.sitterMs)}`);

      const cLines = summarizeChoices(day.choices);
      cLines.forEach(s => lines.push(s));

      if(day.events && day.events.length){
        lines.push(`出来事:`);
        day.events.slice(0,120).forEach(e => {
          lines.push(`  ${formatTime(e.t)}  ${eventToText(e)}`);
        });
      }else{
        lines.push(`出来事: （なし）`);
      }

      lines.forEach(s => {
        const div = document.createElement("div");
        div.className = "logLine";
        div.textContent = s;
        box.appendChild(div);
      });
    }

    $("btn_obs_back").addEventListener("click", () => {
      history.back();
    });
  }

  // シッター切り替え（時間停止）
  function toggleSitter(force=null){
    if(!save.life.bornAt) return;
    if(save.life.isEnded) return;

    const wantOn = (force!=null) ? force : !save.sitter.on;

    if(wantOn && !save.sitter.on){
      save.sitter.on = true;
      save.sitter.onSince = nowMs();
      addEvent("sitterOn", {});
      saveNow();
      renderCare();
      return;
    }
    if(!wantOn && save.sitter.on){
      const used = nowMs() - save.sitter.onSince;
      save.sitter.on = false;
      save.sitter.pausedTotal += used;
      save.sitter.usedTotal += used;

      const d = dayIndex(save);
      const obj = save.logs.day[String(d)];
      if(obj) obj.sitterMs += used;

      save.sitter.onSince = null;
      addEvent("sitterOff", { ms: used });
      saveNow();
      renderCare();
      return;
    }
  }

  function tick(){
    if(!save) return;

    // まだ誕生前（到着待ち）
    if(save.story.arrivalAt && !save.story.hatched){
      maybeHatch();
      return;
    }

    if(save.life.bornAt){
      const prevDay = save._prevDay || dayIndex(save);
      const curDay = dayIndex(save);
      finalizeDayIfNeeded(prevDay, curDay);
      save._prevDay = curDay;

      const effNow = effectiveNow(save);
      const last = save._lastEff || effNow;
      const dt = effNow - last;

      if(dt > 0 && !save.sitter.on && !save.life.isEnded){
        stepByTime(dt);
      }
      save._lastEff = effNow;

      ensureDayHearts();
      maybeEnd();

      if(screens.care.classList.contains("active")){
        renderCare();
      }

      saveNow();
    }
  }

  // 初期化（プレイ）
  function initPlay(){
    setModePill();
    save = loadSave();

    normalizeSaveConfig();

    if(save.playerName){
      $("playerName").value = save.playerName;
      subline.textContent = save.playerName ? `○○（${save.playerName}）の記録` : "記録だけが残る";
    }
    // 画面遷移：まずは物語の入口（必要なら"つづきから"）
    renderOnboarding();

    // ボタン
    const pn = $("playerName");
    if(pn){
      pn.addEventListener("input", () => {
        save.playerName = pn.value;
        saveNow();
        updateStartButton();
      });
    }

    const startBtn = $("btn_start");
    if(startBtn){
      startBtn.addEventListener("click", () => startFromOnboarding());
    }

    $("btn_new_reset").addEventListener("click", () => {
      // 保存を消して、最初に戻る
      resetAll();
      if(pn) pn.value = "";
      renderOnboarding();
    });

    const backIntroBtn = $("btn_back_intro");
    if(backIntroBtn){
      backIntroBtn.addEventListener("click", () => {
        // 進行中なら、軽く確認する
        if(save.story.arrivalAt || save.life.bornAt){
          openChoiceModal("設定へ戻る", "相棒や名前を変えると、探し直しになります。どうしますか？", [
            { label:"戻る", cls:"secondary", onClick: () => { renderOnboarding(); } },
            { label:"やめる", cls:"blue", onClick: () => {} }
          ]);
        }else{
          renderOnboarding();
        }
      });
    }

    $("btn_back_search").addEventListener("click", () => {
      resetSearch();
      buildMap();
      showScreen("search");
      $("searchNote").textContent = "まだ、何も見つからない。";
    });

    $("btn_hint").addEventListener("click", () => {
      if(save.story.foundAt) return;
      const N=12;
      const i = Math.floor(Math.random()*N);
      if(!save.story._revealed.includes(i)) save.story._revealed.push(i);
      saveNow();
      buildMap();
      $("searchNote").textContent = "光の粒が、少しだけ道を示した。";
    });

    $("btn_new_reset").addEventListener("click", () => {
      resetAll();
      showScreen("intro");
      $("searchNote").textContent = "まだ、何も見つからない。";
    });

    // お世話
    $("btn_food").addEventListener("click", actFood);
    $("btn_outing").addEventListener("click", actOuting);
    $("btn_mini").addEventListener("click", actMini);
    $("btn_clean").addEventListener("click", actClean);
    $("btn_drink").addEventListener("click", actDrink);
    $("btn_macaron").addEventListener("click", actMacaron);

    $("btn_logs").addEventListener("click", () => showLogs());
    $("btn_back_care").addEventListener("click", () => {
      if(save.life.isEnded) showEnd();
      else showCare();
    });

    // モーダル
    $("btn_close_modal").addEventListener("click", () => overlay.classList.remove("on"));
    overlay.addEventListener("click", (e) => {
      if(e.target === overlay) overlay.classList.remove("on");
    });

    // シッター
    const tgl = $("toggle_sitter");
    tgl.addEventListener("click", () => toggleSitter());
    tgl.addEventListener("keydown", (e) => {
      if(e.key === "Enter" || e.key === " "){
        e.preventDefault();
        toggleSitter();
      }
    });

    // 共有
    $("btn_copy_share").addEventListener("click", () => copyToClipboard($("shareUrl").value));
    $("btn_copy_share2").addEventListener("click", () => copyToClipboard($("shareUrl2").value));
    $("btn_logs_share").addEventListener("click", () => copyToClipboard($("shareUrl2").value));

    $("btn_end_logs").addEventListener("click", () => showLogs());
    $("btn_end_share").addEventListener("click", () => {
      const u = shareUrlForCurrentSave();
      copyToClipboard(u);
      showLogs();
    });

    // 共有URL初期反映
    const shareUrl = shareUrlForCurrentSave();
    $("shareUrl").value = shareUrl;
    $("shareUrl2").value = shareUrl;
    $("shareBox").style.display = "flex";

    // タイマー
    if(tickTimer) clearInterval(tickTimer);
    tickTimer = setInterval(tick, 900);
    tick();
  }

  setModePill();
  if(isObserveMode){
    initObserve();
    return;
  }

  initPlay();
})();
</script>
</body>
</html>
