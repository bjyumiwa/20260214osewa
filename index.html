<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>3日間のお世話ゲーム（2D / プロトタイプ）</title>
  <style>
    :root{
      --bg0:#050816;
      --bg1:#0b1028;
      --card:rgba(255,255,255,.08);
      --card2:rgba(255,255,255,.12);
      --text:#eef2ff;
      --muted:rgba(238,242,255,.72);
      --line:rgba(255,255,255,.14);
      --good:#9ae6b4;
      --warn:#fbd38d;
      --bad:#feb2b2;
      --accent:#c4b5fd;
      --accent2:#93c5fd;
      --shadow: 0 14px 40px rgba(0,0,0,.35);
      --radius: 18px;
    }
    *{box-sizing:border-box;}
    body{
      margin:0;
      color:var(--text);
      font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Noto Sans JP", "Hiragino Kaku Gothic ProN", "Yu Gothic", sans-serif;
      background: radial-gradient(1200px 800px at 70% 20%, rgba(147,197,253,.12), transparent 55%),
                  radial-gradient(900px 700px at 20% 70%, rgba(196,181,253,.12), transparent 55%),
                  linear-gradient(180deg, var(--bg0), var(--bg1));
      min-height:100vh;
      overflow-x:hidden;
    }
    .wrap{
      max-width: 1060px;
      margin: 0 auto;
      padding: 18px 14px 40px;
    }
    .topbar{
      display:flex;
      gap:12px;
      align-items:center;
      justify-content:space-between;
      padding: 10px 12px;
      border: 1px solid var(--line);
      background: rgba(255,255,255,.05);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      position: sticky;
      top: 10px;
      backdrop-filter: blur(10px);
      z-index: 20;
    }
    .brand{
      display:flex; gap:10px; align-items:center;
      min-width: 220px;
    }
    .brand .dot{
      width:12px;height:12px;border-radius:999px;
      background: radial-gradient(circle at 30% 30%, #fff, rgba(255,255,255,.1)),
                  linear-gradient(180deg, var(--accent), var(--accent2));
      box-shadow: 0 0 18px rgba(196,181,253,.35);
    }
    .brand .title{
      font-weight: 700;
      letter-spacing:.02em;
      font-size: 14px;
      line-height: 1.2;
    }
    .brand .sub{
      font-size: 12px;
      color: var(--muted);
      margin-top: 2px;
    }

    .statusRow{
      display:flex;
      gap: 10px;
      align-items:center;
      justify-content:flex-end;
      flex: 1;
      flex-wrap: wrap;
    }

    .pill{
      display:flex;
      align-items:center;
      gap:8px;
      padding: 8px 10px;
      border: 1px solid var(--line);
      background: rgba(255,255,255,.05);
      border-radius: 999px;
      min-height: 34px;
    }
    .pill small{color: var(--muted);}
    .hearts{
      width: 140px;
      height: 10px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,.18);
      background: rgba(255,255,255,.08);
      overflow:hidden;
      position: relative;
    }
    .hearts > i{
      display:block;
      height:100%;
      width:50%;
      background: linear-gradient(90deg, rgba(196,181,253,.95), rgba(147,197,253,.95));
      box-shadow: 0 0 14px rgba(147,197,253,.25);
    }
    .heartIcon{
      width:16px;height:16px; display:inline-block;
      background: radial-gradient(circle at 30% 30%, #fff, rgba(255,255,255,.1)),
                  linear-gradient(180deg, rgba(251,113,133,.95), rgba(196,181,253,.85));
      clip-path: path("M8 14s6-3.3 6-7.2C14 4.6 12.8 3 10.8 3 9.6 3 8.7 3.7 8 4.6 7.3 3.7 6.4 3 5.2 3 3.2 3 2 4.6 2 6.8 2 10.7 8 14 8 14Z");
      opacity:.95;
    }

    .toggle{
      display:flex;
      align-items:center;
      gap:8px;
      cursor:pointer;
      user-select:none;
    }
    .switch{
      width:42px;height:24px;border-radius:999px;
      border: 1px solid rgba(255,255,255,.22);
      background: rgba(255,255,255,.08);
      position: relative;
      transition: .18s ease;
    }
    .switch::after{
      content:"";
      width:18px;height:18px;border-radius:999px;
      position:absolute; top:2px; left:2px;
      background: rgba(255,255,255,.85);
      box-shadow: 0 8px 14px rgba(0,0,0,.25);
      transition: .18s ease;
    }
    .toggle[data-on="true"] .switch{
      background: rgba(154,230,180,.18);
      border-color: rgba(154,230,180,.28);
    }
    .toggle[data-on="true"] .switch::after{
      left: 20px;
      background: rgba(154,230,180,.95);
    }

    .main{
      margin-top: 14px;
      display:grid;
      grid-template-columns: 1.5fr 1fr;
      gap: 14px;
      align-items: start;
    }

    .card{
      border: 1px solid var(--line);
      background: rgba(255,255,255,.05);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      overflow:hidden;
    }
    .cardHeader{
      padding: 12px 12px 10px;
      border-bottom: 1px solid rgba(255,255,255,.08);
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap: 10px;
    }
    .cardHeader .h{
      font-weight: 700;
      font-size: 14px;
    }
    .cardHeader .hint{
      font-size:12px;color:var(--muted);
    }

    .stage{
      position: relative;
      min-height: 520px;
      padding: 14px;
    }
    .sky{
      position:absolute; inset:0;
      background:
        radial-gradient(1200px 700px at 60% 10%, rgba(196,181,253,.10), transparent 60%),
        radial-gradient(900px 600px at 15% 80%, rgba(147,197,253,.10), transparent 60%),
        linear-gradient(180deg, rgba(255,255,255,.03), rgba(0,0,0,0));
      pointer-events:none;
    }
    .stars{
      position:absolute; inset:0;
      pointer-events:none;
      opacity:.55;
      background-image:
        radial-gradient(circle at 10% 20%, rgba(255,255,255,.8) 0 1px, transparent 2px),
        radial-gradient(circle at 40% 70%, rgba(255,255,255,.7) 0 1px, transparent 2px),
        radial-gradient(circle at 70% 30%, rgba(255,255,255,.7) 0 1px, transparent 2px),
        radial-gradient(circle at 85% 75%, rgba(255,255,255,.7) 0 1px, transparent 2px),
        radial-gradient(circle at 25% 50%, rgba(255,255,255,.55) 0 1px, transparent 2px);
      background-size: 420px 260px;
      filter: blur(.2px);
      animation: drift 18s linear infinite;
    }
    @keyframes drift{
      0%{transform: translate3d(0,0,0);}
      100%{transform: translate3d(-80px, 50px, 0);}
    }

    .center{
      position:absolute;
      left:50%;
      top: 55%;
      transform: translate(-50%,-50%);
      width: 100%;
      max-width: 540px;
      display:flex;
      flex-direction:column;
      align-items:center;
      gap: 12px;
      padding: 12px;
    }

    .dayDots{
      display:flex; gap:8px; align-items:center; justify-content:center;
      opacity:.85;
    }
    .dayDots span{
      width:10px;height:10px;border-radius:999px;
      border: 1px solid rgba(255,255,255,.22);
      background: rgba(255,255,255,.08);
    }
    .dayDots span.on{
      background: linear-gradient(180deg, rgba(196,181,253,.95), rgba(147,197,253,.95));
      box-shadow: 0 0 12px rgba(147,197,253,.25);
      border-color: rgba(147,197,253,.32);
    }

    .entity{
      width: 260px;
      height: 260px;
      display:grid;
      place-items:center;
      position: relative;
    }
    .floaty{
      animation: floaty 2.6s ease-in-out infinite;
    }
    @keyframes floaty{
      0%,100%{transform: translateY(0);}
      50%{transform: translateY(-10px);}
    }

    .egg, .macaron, .drink, .charImg{
      width: 170px;
      height: 170px;
      object-fit: contain;
      filter: drop-shadow(0 18px 26px rgba(0,0,0,.35));
      opacity: .98;
    }
    .eggWrap{
      width: 190px; height: 190px;
      display:grid; place-items:center;
      border-radius: 999px;
      background: radial-gradient(circle at 30% 20%, rgba(255,255,255,.22), rgba(255,255,255,.04));
      border: 1px solid rgba(255,255,255,.14);
      box-shadow: inset 0 0 0 1px rgba(255,255,255,.04);
      position: relative;
    }
    .eggWrap::after{
      content:"";
      position:absolute; inset:-12px;
      border-radius: 999px;
      background: radial-gradient(circle at 50% 50%, rgba(196,181,253,.18), transparent 60%);
      filter: blur(8px);
      opacity: .9;
      pointer-events:none;
    }
    .hatchLift{
      animation: hatchLift 2.2s ease-in-out 1;
    }
    @keyframes hatchLift{
      0%{transform: translateY(0) scale(1); opacity: 1;}
      55%{transform: translateY(-26px) scale(1.02); opacity: 1;}
      100%{transform: translateY(-60px) scale(.95); opacity: 0;}
    }

    .char{
      width: 220px;
      height: 220px;
      border-radius: 34px;
      background: radial-gradient(circle at 30% 20%, rgba(255,255,255,.18), rgba(255,255,255,.06)),
                  linear-gradient(180deg, rgba(196,181,253,.22), rgba(147,197,253,.12));
      border: 1px solid rgba(255,255,255,.16);
      box-shadow: 0 18px 30px rgba(0,0,0,.28);
      position: relative;
      overflow:hidden;
      display:grid;
      place-items:center;
    }

    .face{
      width: 190px;
      height: 190px;
      position: relative;
    }
    .eye{
      position:absolute;
      top: 68px;
      width: 34px; height: 46px;
      border-radius: 999px;
      background: rgba(255,255,255,.86);
      box-shadow: inset 0 -10px 14px rgba(0,0,0,.08);
      overflow:hidden;
    }
    .eye::after{
      content:"";
      position:absolute;
      width: 12px; height: 18px;
      border-radius: 999px;
      background: rgba(15,23,42,.85);
      left: 12px; top: 18px;
      transition: .18s ease;
    }
    .eye.left{left: 40px;}
    .eye.right{right: 40px;}
    .brow{
      position:absolute;
      top: 52px;
      width: 44px; height: 8px;
      border-radius: 999px;
      background: rgba(255,255,255,.22);
      filter: blur(.1px);
      opacity:.9;
      transform-origin: center;
      transition: .18s ease;
    }
    .brow.left{left: 34px;}
    .brow.right{right: 34px;}
    .mouth{
      position:absolute;
      left:50%;
      top: 126px;
      transform: translateX(-50%);
      width: 70px; height: 36px;
      border: 3px solid rgba(255,255,255,.52);
      border-top: 0;
      border-left-color: rgba(255,255,255,.65);
      border-right-color: rgba(255,255,255,.65);
      border-bottom-color: rgba(255,255,255,.72);
      border-radius: 0 0 999px 999px;
      opacity:.95;
      transition: .18s ease;
    }
    .blush{
      position:absolute;
      top: 112px;
      width: 36px; height: 18px;
      border-radius: 999px;
      background: rgba(251,113,133,.16);
      filter: blur(.2px);
      opacity:.8;
      transition:.18s ease;
    }
    .blush.left{left: 26px;}
    .blush.right{right: 26px;}

    .tears{
      position:absolute;
      inset:0;
      pointer-events:none;
      opacity:0;
      transition:.18s ease;
    }
    .tear{
      position:absolute;
      width: 10px; height: 18px;
      border-radius: 999px;
      background: rgba(147,197,253,.72);
      left: 62px; top: 116px;
      transform: rotate(10deg);
      animation: tearDrop 1.2s ease-in-out infinite;
    }
    .tear:nth-child(2){
      left: 148px; top: 118px;
      transform: rotate(-8deg);
      animation-delay: .22s;
      opacity:.9;
    }
    @keyframes tearDrop{
      0%{transform: translateY(0) scale(1) rotate(10deg); opacity:.0;}
      35%{opacity:.75;}
      100%{transform: translateY(26px) scale(.95) rotate(10deg); opacity:0;}
    }

    .stateGlow{
      position:absolute;
      inset:-30px;
      background: radial-gradient(circle at 50% 50%, rgba(154,230,180,.16), transparent 60%);
      filter: blur(10px);
      opacity: .0;
      transition: .18s ease;
      pointer-events:none;
    }

    .char.lively .stateGlow{opacity:.85;}
    .char.lively{animation: livelyBounce 1.4s ease-in-out infinite;}
    @keyframes livelyBounce{
      0%,100%{transform: translateY(0) rotate(0deg);}
      50%{transform: translateY(-7px) rotate(.6deg);}
    }

    .char.low .mouth{
      width: 62px;
      height: 24px;
      border: 3px solid rgba(255,255,255,.45);
      border-bottom: 0;
      border-radius: 999px 999px 0 0;
      top: 136px;
      opacity:.8;
    }
    .char.low .eye::after{top: 22px;}
    .char.low{filter:saturate(.9);}

    .char.cry .mouth{
      width: 62px;
      height: 24px;
      border: 3px solid rgba(255,255,255,.52);
      border-bottom: 0;
      border-radius: 999px 999px 0 0;
      top: 138px;
      opacity:.9;
      transform: translateX(-50%) rotate(0deg);
    }
    .char.cry .brow.left{transform: rotate(12deg) translateY(1px);}
    .char.cry .brow.right{transform: rotate(-12deg) translateY(1px);}
    .char.cry .tears{opacity:1;}
    .char.cry{filter:saturate(.85) contrast(1.02);}

    .char.uncanny{
      animation: uncanny 0.18s steps(2) infinite;
      filter: saturate(.75) contrast(1.05) hue-rotate(14deg);
    }
    @keyframes uncanny{
      0%{transform: translate(0,0) skewX(0deg);}
      50%{transform: translate(2px,-1px) skewX(1deg);}
      100%{transform: translate(-1px,1px) skewX(-1deg);}
    }

    .poops{
      position:absolute;
      left: 18px;
      bottom: 18px;
      display:flex;
      gap: 8px;
      align-items:center;
      opacity:.95;
    }
    .poop{
      width: 18px; height: 18px;
      border-radius: 6px;
      background: linear-gradient(180deg, rgba(251,146,60,.92), rgba(234,179,8,.82));
      border: 1px solid rgba(255,255,255,.12);
      box-shadow: 0 10px 16px rgba(0,0,0,.25);
      transform: rotate(-8deg);
      opacity:.0;
      transition: .18s ease;
    }
    .poop.on{opacity:.95;}
    .poop:nth-child(2){transform: rotate(9deg) translateY(-2px);}
    .poop:nth-child(3){transform: rotate(-4deg) translateY(1px);}

    .stageNote{
      margin-top: 8px;
      font-size: 12px;
      color: var(--muted);
      text-align:center;
      opacity:.95;
      line-height: 1.6;
    }

    .actions{
      padding: 12px;
      display:flex;
      flex-direction:column;
      gap: 10px;
    }
    .grid{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap: 10px;
    }
    button{
      appearance:none;
      border: 1px solid rgba(255,255,255,.16);
      background: rgba(255,255,255,.06);
      color: var(--text);
      border-radius: 14px;
      padding: 12px 10px;
      cursor:pointer;
      font-weight: 650;
      letter-spacing:.01em;
      box-shadow: 0 12px 26px rgba(0,0,0,.22);
      transition: transform .08s ease, background .18s ease, border-color .18s ease, opacity .18s ease;
    }
    button:hover{transform: translateY(-1px); background: rgba(255,255,255,.09); border-color: rgba(255,255,255,.22);}
    button:active{transform: translateY(0px) scale(.99);}
    button[disabled]{opacity:.45; cursor:not-allowed; transform:none;}
    .btnRow{
      display:flex;
      gap: 10px;
      flex-wrap: wrap;
    }
    .btnSoft{
      flex: 1;
      min-width: 140px;
    }
    .btnGhost{
      background: rgba(255,255,255,.03);
    }

    .rightPane{
      display:flex;
      flex-direction:column;
      gap: 14px;
    }

    .logPane{
      padding: 12px;
    }
    .logPane .mini{
      font-size: 12px;
      color: var(--muted);
      line-height: 1.6;
    }
    .logList{
      margin-top: 10px;
      display:flex;
      flex-direction:column;
      gap: 8px;
      max-height: 290px;
      overflow:auto;
      padding-right: 6px;
    }
    .logItem{
      border: 1px solid rgba(255,255,255,.10);
      background: rgba(255,255,255,.04);
      border-radius: 14px;
      padding: 10px 10px;
      font-size: 12px;
      line-height: 1.5;
    }
    .logItem b{font-size:12px;}
    .logItem .t{color: var(--muted); margin-top: 2px; font-size: 11px;}

    .modalBack{
      position: fixed;
      inset:0;
      background: rgba(0,0,0,.55);
      display:none;
      place-items:center;
      z-index: 99;
      padding: 18px;
    }
    .modalBack.show{display:grid;}
    .modal{
      width: min(560px, 96vw);
      border: 1px solid rgba(255,255,255,.16);
      background: rgba(16,18,34,.88);
      border-radius: 18px;
      box-shadow: 0 22px 60px rgba(0,0,0,.45);
      overflow:hidden;
      backdrop-filter: blur(12px);
    }
    .modalHead{
      padding: 12px 12px 10px;
      border-bottom: 1px solid rgba(255,255,255,.10);
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap: 10px;
    }
    .modalHead .h{
      font-weight: 750;
      font-size: 14px;
      letter-spacing:.02em;
    }
    .modalBody{
      padding: 12px;
    }
    .two{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap: 10px;
      margin-top: 10px;
    }
    .choice{
      text-align:left;
      padding: 12px;
      border-radius: 16px;
      border: 1px solid rgba(255,255,255,.14);
      background: rgba(255,255,255,.05);
      cursor:pointer;
      transition: .18s ease;
      min-height: 96px;
      display:flex;
      flex-direction:column;
      gap: 6px;
      justify-content:center;
    }
    .choice:hover{
      background: rgba(255,255,255,.08);
      border-color: rgba(255,255,255,.22);
      transform: translateY(-1px);
    }
    .choice .cTitle{font-weight: 750; font-size: 13px;}
    .choice .cSub{font-size: 12px; color: var(--muted); line-height:1.5;}
    .modalFoot{
      padding: 10px 12px 12px;
      border-top: 1px solid rgba(255,255,255,.10);
      display:flex;
      gap: 10px;
      justify-content:flex-end;
      flex-wrap: wrap;
    }

    .centerOverlay{
      position:absolute;
      inset:0;
      display:none;
      place-items:center;
      z-index: 10;
      pointer-events: none;
    }
    .centerOverlay.show{display:grid;}
    .thanks{
      font-weight: 800;
      font-size: 44px;
      letter-spacing: .06em;
      text-shadow: 0 18px 48px rgba(0,0,0,.45);
      opacity:.98;
    }

    .screen{
      display:none;
    }
    .screen.show{display:block;}

    .observeWrap{
      padding: 12px;
    }
    .observeHeader{
      display:flex;
      gap: 10px;
      align-items:flex-start;
      justify-content:space-between;
      flex-wrap: wrap;
    }
    .observeHeader .h{
      font-weight: 800;
      font-size: 16px;
      letter-spacing:.02em;
    }
    .observeHeader .p{
      margin-top: 4px;
      font-size: 12px;
      color: var(--muted);
      line-height:1.6;
    }
    .chartBox{
      margin-top: 12px;
      border: 1px solid rgba(255,255,255,.12);
      background: rgba(255,255,255,.04);
      border-radius: 16px;
      padding: 10px;
    }
    canvas{width:100%; height:160px; display:block;}
    .days{
      margin-top: 12px;
      display:flex;
      flex-direction:column;
      gap: 10px;
    }
    .dayCard{
      border: 1px solid rgba(255,255,255,.12);
      background: rgba(255,255,255,.04);
      border-radius: 16px;
      padding: 10px;
    }
    .dayCard .dh{
      display:flex; justify-content:space-between; gap:10px; flex-wrap:wrap;
      align-items:center;
      margin-bottom: 8px;
    }
    .dayCard .dh b{font-size: 13px;}
    .dayCard .dh small{color: var(--muted);}
    .kvs{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap: 8px 10px;
      font-size: 12px;
      color: rgba(238,242,255,.88);
      line-height:1.6;
    }
    .kvs span{color: var(--muted);}
    .choices{
      margin-top: 8px;
      border-top: 1px solid rgba(255,255,255,.10);
      padding-top: 8px;
      font-size: 12px;
      color: rgba(238,242,255,.88);
      line-height:1.7;
      white-space: pre-wrap;
    }

    @media (max-width: 860px){
      .main{grid-template-columns: 1fr;}
      .brand{min-width: auto;}
      .hearts{width: 120px;}
    }
    @media (prefers-reduced-motion: reduce){
      *{animation:none !important; transition:none !important;}
    }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="topbar" id="topbar">
      <div class="brand">
        <div class="dot"></div>
        <div>
          <div class="title">3日間のお世話ゲーム（2D）</div>
          <div class="sub" id="subline">ログだけが残ります</div>
        </div>
      </div>

      <div class="statusRow">
        <div class="pill" title="関係性の指標（スコアとして強調しません）">
          <span class="heartIcon" aria-hidden="true"></span>
          <div class="hearts" aria-hidden="true"><i id="heartFill"></i></div>
          <small id="heartSmall"> </small>
        </div>

        <div class="pill">
          <div class="dayDots" aria-hidden="true">
            <span id="d1"></span><span id="d2"></span><span id="d3"></span>
          </div>
          <small id="daySmall"> </small>
        </div>

        <div class="pill toggle" id="sitterToggle" data-on="false" title="シッターONで時間が止まります（寿命・空腹・排泄・状態変化すべて停止）">
          <small>シッター</small>
          <div class="switch" aria-hidden="true"></div>
        </div>
      </div>
    </div>

    <div id="screenGame" class="screen show">
      <div class="main">
        <div class="card">
          <div class="cardHeader">
            <div>
              <div class="h">ステージ</div>
              <div class="hint" id="stageHint"> </div>
            </div>
            <div class="btnRow">
              <button class="btnGhost" id="btnShare">観察用URL</button>
              <button class="btnGhost" id="btnLogs">ログ</button>
              <button class="btnGhost" id="btnReset">はじめから</button>
            </div>
          </div>

          <div class="stage" id="stage">
            <div class="sky"></div>
            <div class="stars"></div>

            <div class="center">
              <div class="entity">
                <div id="eggArea" class="eggWrap floaty" style="display:none;">
                  <img id="eggImg" class="egg" alt="" src="public/assets/egg.png" />
                </div>

                <div id="charArea" class="char floaty" style="display:none;">
                  <div class="stateGlow"></div>
                  <div class="face" aria-hidden="true">
                    <div class="brow left"></div>
                    <div class="brow right"></div>
                    <div class="eye left"></div>
                    <div class="eye right"></div>
                    <div class="mouth"></div>
                    <div class="blush left"></div>
                    <div class="blush right"></div>
                    <div class="tears">
                      <div class="tear"></div>
                      <div class="tear"></div>
                    </div>
                  </div>
                </div>
              </div>

              <div class="poops" aria-hidden="true">
                <div class="poop" id="poop1"></div>
                <div class="poop" id="poop2"></div>
                <div class="poop" id="poop3"></div>
              </div>

              <div class="stageNote" id="stageNote"></div>
            </div>

            <div class="centerOverlay" id="thanksOverlay" aria-hidden="true">
              <div class="thanks">ありがとう</div>
            </div>
          </div>
        </div>

        <div class="rightPane">
          <div class="card">
            <div class="cardHeader">
              <div>
                <div class="h">お世話</div>
                <div class="hint">全部2択。正解はありません</div>
              </div>
            </div>
            <div class="actions">
              <div class="grid">
                <button id="btnFood">食事</button>
                <button id="btnOut">お出かけ</button>
                <button id="btnMini">2択ミニゲーム</button>
                <button id="btnClean">排泄除去</button>
              </div>
              <div class="grid">
                <button id="btnDrink" class="btnSoft">ドリンク</button>
                <button id="btnMacaron" class="btnSoft" disabled>マカロン</button>
              </div>
              <div class="btnRow">
                <button id="btnSaveHint" class="btnGhost btnSoft">保存について</button>
              </div>
            </div>
          </div>

          <div class="card">
            <div class="cardHeader">
              <div>
                <div class="h">いま起きたこと</div>
                <div class="hint">評価せず、事実として残します</div>
              </div>
            </div>
            <div class="logPane">
              <div class="mini" id="miniText">
                画面の表情や動きだけで状態が変わります。ラベルは出しません。
              </div>
              <div class="logList" id="liveLog"></div>
            </div>
          </div>
        </div>
      </div>
    </div>

    <div id="screenObserve" class="screen">
      <div class="card">
        <div class="cardHeader">
          <div>
            <div class="h">観察用ログ</div>
            <div class="hint">操作はできません（ログとハート推移のみ）</div>
          </div>
          <div class="btnRow">
            <button id="btnBackToGame" class="btnGhost">戻る</button>
          </div>
        </div>

        <div class="observeWrap">
          <div class="observeHeader">
            <div>
              <div class="h" id="obsTitle"> </div>
              <div class="p" id="obsSub"> </div>
            </div>
          </div>

          <div class="chartBox">
            <canvas id="heartChart" width="900" height="220"></canvas>
          </div>

          <div class="days" id="obsDays"></div>
        </div>
      </div>
    </div>
  </div>

  <div class="modalBack" id="modalBack" role="dialog" aria-modal="true" aria-hidden="true">
    <div class="modal">
      <div class="modalHead">
        <div>
          <div class="h" id="modalTitle"> </div>
          <div class="hint" id="modalHint"> </div>
        </div>
        <button id="modalX" class="btnGhost" style="padding:8px 10px;">閉じる</button>
      </div>
      <div class="modalBody" id="modalBody"></div>
      <div class="modalFoot" id="modalFoot"></div>
    </div>
  </div>

<script>
(() => {
  "use strict";

  const SAVE_KEY = "osewa_save_v1";
  const ARCHIVE_KEY = "osewa_archives_v1";

  const DAY_MS = 24 * 60 * 60 * 1000;
  const LIFE_MS = 3 * DAY_MS;
  const HATCH_MS_DEFAULT = 3 * 60 * 1000;

  // テスト用：URLに ?fast=1 を付けると孵化が短くなります
  const url = new URL(location.href);
  const FAST = url.searchParams.get("fast") === "1";
  const HATCH_MS = FAST ? 20 * 1000 : HATCH_MS_DEFAULT;

  // マカロン復活（死後）: どこか違和感のある一時復活
  const MACARON_MS = FAST ? 25 * 1000 : 10 * 60 * 1000;

  // ドリンク（生存中）: 少し戻す／延ばす
  const DRINK_LIFE_EXTEND_MS = FAST ? 25 * 1000 : 60 * 60 * 1000;
  const DRINK_BACK_MS = FAST ? 10 * 1000 : 30 * 60 * 1000;

  // 状態変化レート（ざっくり）
  const HUNGER_PER_MIN = 0.25; // 1分で+0.25
  const DIRT_PER_MIN   = 0.18;

  const $ = (q) => document.querySelector(q);
  const el = (id) => document.getElementById(id);

  const ui = {
    subline: el("subline"),
    heartFill: el("heartFill"),
    heartSmall: el("heartSmall"),
    d1: el("d1"), d2: el("d2"), d3: el("d3"),
    daySmall: el("daySmall"),
    sitterToggle: el("sitterToggle"),

    stageHint: el("stageHint"),
    stageNote: el("stageNote"),
    eggArea: el("eggArea"),
    eggImg: el("eggImg"),
    charArea: el("charArea"),
    thanksOverlay: el("thanksOverlay"),

    poop1: el("poop1"),
    poop2: el("poop2"),
    poop3: el("poop3"),

    btnFood: el("btnFood"),
    btnOut: el("btnOut"),
    btnMini: el("btnMini"),
    btnClean: el("btnClean"),
    btnDrink: el("btnDrink"),
    btnMacaron: el("btnMacaron"),
    btnShare: el("btnShare"),
    btnLogs: el("btnLogs"),
    btnReset: el("btnReset"),
    btnSaveHint: el("btnSaveHint"),

    liveLog: el("liveLog"),

    modalBack: el("modalBack"),
    modalTitle: el("modalTitle"),
    modalHint: el("modalHint"),
    modalBody: el("modalBody"),
    modalFoot: el("modalFoot"),
    modalX: el("modalX"),

    screenGame: el("screenGame"),
    screenObserve: el("screenObserve"),
    obsTitle: el("obsTitle"),
    obsSub: el("obsSub"),
    obsDays: el("obsDays"),
    btnBackToGame: el("btnBackToGame"),
    heartChart: el("heartChart"),
  };

  function clamp(v, a, b){ return Math.max(a, Math.min(b, v)); }

  function now(){ return Date.now(); }

  function uid(){
    try{
      const a = new Uint32Array(4);
      crypto.getRandomValues(a);
      return [...a].map(x => x.toString(16).padStart(8,"0")).join("");
    }catch(e){
      return "id_" + Math.random().toString(16).slice(2) + "_" + now().toString(16);
    }
  }

  function safeJsonParse(s){
    try{ return JSON.parse(s); }catch(e){ return null; }
  }

  function loadSave(){
    const raw = localStorage.getItem(SAVE_KEY);
    if(!raw) return null;
    const obj = safeJsonParse(raw);
    if(!obj || obj.version !== 1) return null;
    return obj;
  }

  function saveSave(obj){
    localStorage.setItem(SAVE_KEY, JSON.stringify(obj));
  }

  function loadArchives(){
    const raw = localStorage.getItem(ARCHIVE_KEY);
    const arr = raw ? safeJsonParse(raw) : null;
    return Array.isArray(arr) ? arr : [];
  }

  function saveArchives(arr){
    localStorage.setItem(ARCHIVE_KEY, JSON.stringify(arr));
  }

  function calcElapsedMs(save, tNow){
    // シッター中は elapsed が進まない（寿命・空腹・排泄・状態変化が停止）
    const baseNow = save.pausedSince ? save.pausedSince : tNow;
    return Math.max(0, baseNow - save.startedAt - save.totalPausedMs);
  }

  function dayIndex(elapsed){
    return clamp(Math.floor(elapsed / DAY_MS) + 1, 1, 3);
  }

  function ensureDay(save, d){
    if(!save.days) save.days = {};
    if(!save.days[d]){
      save.days[d] = {
        day: d,
        careCounts: { food:0, out:0, mini:0, clean:0 },
        choices: [],
        heartChange: 0,
        sitterMs: 0,
        items: { drink:0, macaron:0 },
        startedAt: now(),
        heartStart: save.heart,
        heartEnd: save.heart
      };
    }
    return save.days[d];
  }

  function pushLiveLog(save, text){
    if(!save.live) save.live = [];
    const stamp = now();
    save.live.unshift({ t: stamp, text });
    if(save.live.length > 30) save.live.length = 30;
  }

  function formatClock(t){
    const d = new Date(t);
    const hh = String(d.getHours()).padStart(2,"0");
    const mm = String(d.getMinutes()).padStart(2,"0");
    return `${hh}:${mm}`;
  }

  function createNewSave(){
    const t = now();
    const playerId = uid();
    const s = {
      version: 1,
      playerId,
      startedAt: t,
      totalPausedMs: 0,
      pausedSince: null,

      hatched: false,
      hatchAnim: false,

      ended: false,
      endedAt: null,

      // 復活系
      macaronActive: false,
      macaronEndsAtElapsed: null, // elapsed基準
      lifeExtensionMs: 0,         // ドリンクなどで伸ばす

      // 状態
      heart: 50,
      hunger: 20,
      dirt: 10,
      mood: 70,
      poop: 0,

      // シミュレーション用
      lastSimElapsed: 0,
      currentDay: 1,

      days: {},
      live: []
    };
    ensureDay(s, 1);
    pushLiveLog(s, "到着した。");
    return s;
  }

  function isAlive(save, elapsed){
    // 3日経過で終了。ただしドリンクの延長あり。
    const deadline = LIFE_MS + (save.lifeExtensionMs || 0);
    const notPast = elapsed < deadline;
    const notEndedFlag = !save.ended;
    if(save.macaronActive) return true; // 死後の一時復活
    return notPast && notEndedFlag;
  }

  function canInteract(save, elapsed){
    if(save.pausedSince) return true; // シッター中でも操作は許可（時間だけ止まる）
    if(save.macaronActive) return true;
    if(save.ended) return false;
    // 孵化前は一部だけ（ログ/共有などはOK）
    if(!save.hatched){
      return false;
    }
    // 生存中のみ
    return isAlive(save, elapsed);
  }

  function updatePoop(save){
    // 汚れが溜まるほど増える（0〜3）
    const desired = clamp(Math.floor((save.dirt - 50) / 20), 0, 3);
    save.poop = Math.max(save.poop, desired);
    if(save.poop === 0) return;
  }

  function applyTimeSimulation(save, elapsed){
    const prev = save.lastSimElapsed || 0;
    const deltaMs = Math.max(0, elapsed - prev);
    if(deltaMs <= 0) return;

    const minutes = deltaMs / 60000;
    save.hunger = clamp(save.hunger + minutes * HUNGER_PER_MIN, 0, 100);
    save.dirt   = clamp(save.dirt   + minutes * DIRT_PER_MIN,   0, 100);

    updatePoop(save);

    // ムードは、汚れ・空腹・排泄でゆっくり変化
    let moodDelta = 0;

    const stress = (save.hunger > 70 ? (save.hunger - 70) / 30 : 0) + (save.dirt > 70 ? (save.dirt - 70) / 30 : 0);
    moodDelta -= minutes * 0.35 * stress;

    if(save.poop > 0){
      moodDelta -= minutes * 0.12 * save.poop;
    }

    // しばらく良い状態なら少し回復
    if(save.hunger < 35 && save.dirt < 35 && save.poop === 0){
      moodDelta += minutes * 0.10;
    }

    save.mood = clamp(save.mood + moodDelta, 0, 100);
  }

  function updateDayBoundary(save, elapsed){
    const d = dayIndex(elapsed);
    if(!save.currentDay) save.currentDay = d;

    if(d !== save.currentDay){
      // 前日の締め
      const prev = ensureDay(save, save.currentDay);
      prev.heartEnd = save.heart;

      // 新日
      save.currentDay = d;
      const next = ensureDay(save, d);
      next.heartStart = save.heart;
      pushLiveLog(save, `日が変わった。`);
    }
    ensureDay(save, save.currentDay);
  }

  function maybeHatch(save, elapsed){
    if(save.hatched) return;

    if(elapsed >= HATCH_MS){
      save.hatchAnim = true;
      // 演出のため少し遅れて孵化フラグ
      setTimeout(() => {
        const s = loadSave();
        if(!s || s.hatched) return;
        s.hatched = true;
        s.hatchAnim = false;
        pushLiveLog(s, "浮かび上がって、誕生した。");
        saveSave(s);
      }, 900);
    }
  }

  function maybeEnd(save, elapsed){
    if(save.macaronActive) return;

    const deadline = LIFE_MS + (save.lifeExtensionMs || 0);
    if(!save.ended && elapsed >= deadline){
      save.ended = true;
      save.endedAt = now();
      pushLiveLog(save, "いなくなった。");
      // 終了アーカイブとして保存（観察用の材料）
      archiveRun(save);
    }
  }

  function archiveRun(save){
    // 既に同じplayerIdで入っていれば追加しない
    const arr = loadArchives();
    const exist = arr.some(x => x && x.playerId === save.playerId && x.startedAt === save.startedAt);
    if(exist) return;

    const exp = exportObservationData(save);
    arr.unshift(exp);
    if(arr.length > 20) arr.length = 20;
    saveArchives(arr);
  }

  function updateMacaronTimer(save, elapsed){
    if(!save.macaronActive) return;
    if(save.macaronEndsAtElapsed == null) return;

    if(elapsed >= save.macaronEndsAtElapsed){
      save.macaronActive = false;
      save.macaronEndsAtElapsed = null;
      // 復活はハッピーエンド扱いにしない。終わりは戻る。
      save.ended = true;
      save.endedAt = now();
      pushLiveLog(save, "どこかズレたまま、また静かになった。");
      archiveRun(save);
    }
  }

  function stateClass(save){
    // ラベルは出さず、表情と動きだけ
    const hungry = save.hunger;
    const dirty = save.dirt;
    const mood = save.mood;
    const poop = save.poop;

    // 泣きに寄せる条件
    if(mood < 25 || hungry > 85 || dirty > 85 || poop >= 3) return "cry";
    // 元気がない
    if(mood < 45 || hungry > 70 || dirty > 70 || poop >= 2) return "low";
    // 元気
    if(mood > 70 && hungry < 55 && dirty < 55 && poop === 0) return "lively";
    return ""; // 普通
  }

  function setInteractable(enabled){
    const btns = [ui.btnFood, ui.btnOut, ui.btnMini, ui.btnClean, ui.btnDrink];
    btns.forEach(b => b.disabled = !enabled);
  }

  function render(save){
    const tNow = now();
    const elapsed = calcElapsedMs(save, tNow);
    const d = dayIndex(elapsed);

    ui.heartFill.style.width = clamp(save.heart, 0, 100) + "%";
    ui.heartSmall.textContent = " ";

    // day dots
    ui.d1.className = (d >= 1) ? "on" : "";
    ui.d2.className = (d >= 2) ? "on" : "";
    ui.d3.className = (d >= 3) ? "on" : "";
    ui.daySmall.textContent = " ";

    const paused = !!save.pausedSince;
    ui.sitterToggle.dataset.on = paused ? "true" : "false";

    // 孵化前後の表示
    if(!save.hatched){
      ui.eggArea.style.display = "grid";
      ui.charArea.style.display = "none";

      ui.stageHint.textContent = paused ? "時間が止まっている。" : "しばらくして、浮かび上がる。";
      ui.stageNote.textContent = paused ? "いまは預けている。" : "見守るしかない時間。";

      // 孵化演出
      ui.eggArea.classList.toggle("hatchLift", !!save.hatchAnim);
    }else{
      ui.eggArea.style.display = "none";
      ui.charArea.style.display = "grid";

      // 状態クラス
      ui.charArea.classList.remove("lively","low","cry","uncanny");
      const sc = stateClass(save);
      if(sc) ui.charArea.classList.add(sc);

      // 復活時の違和感
      if(save.macaronActive) ui.charArea.classList.add("uncanny");

      if(save.ended && !save.macaronActive){
        ui.stageHint.textContent = " ";
        ui.stageNote.textContent = " ";
      }else{
        ui.stageHint.textContent = paused ? "時間が止まっている。" : " ";
        ui.stageNote.textContent = " ";
      }
    }

    // 排泄表示
    ui.poop1.classList.toggle("on", save.poop >= 1);
    ui.poop2.classList.toggle("on", save.poop >= 2);
    ui.poop3.classList.toggle("on", save.poop >= 3);

    // 生存・終了
    const alive = isAlive(save, elapsed);
    const interact = canInteract(save, elapsed);

    // マカロンは死後に使える（死んでいるとき有効）
    const canMacaron = save.ended && !save.macaronActive;
    ui.btnMacaron.disabled = !canMacaron;

    // 操作の可否（シッター中でも操作は可能、ただし孵化前は不可）
    setInteractable(interact);

    // ありがとう
    ui.thanksOverlay.classList.toggle("show", save.ended && !save.macaronActive);

    // ライブログ表示
    ui.liveLog.innerHTML = "";
    const items = (save.live || []).slice(0, 14);
    items.forEach(it => {
      const div = document.createElement("div");
      div.className = "logItem";
      div.innerHTML = `<b>${escapeHtml(it.text)}</b><div class="t">${formatClock(it.t)}</div>`;
      ui.liveLog.appendChild(div);
    });

    // サブライン
    ui.subline.textContent = (save.ended && !save.macaronActive)
      ? "操作は停止します"
      : "ログだけが残ります";
  }

  function escapeHtml(s){
    return String(s).replace(/[&<>"']/g, m => ({
      "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#39;"
    }[m]));
  }

  function openModal(title, hint, bodyNode, footButtons){
    ui.modalTitle.textContent = title || "";
    ui.modalHint.textContent = hint || "";
    ui.modalBody.innerHTML = "";
    ui.modalBody.appendChild(bodyNode);

    ui.modalFoot.innerHTML = "";
    footButtons.forEach(btn => ui.modalFoot.appendChild(btn));

    ui.modalBack.classList.add("show");
    ui.modalBack.setAttribute("aria-hidden","false");
  }

  function closeModal(){
    ui.modalBack.classList.remove("show");
    ui.modalBack.setAttribute("aria-hidden","true");
  }

  ui.modalX.addEventListener("click", closeModal);
  ui.modalBack.addEventListener("click", (e) => { if(e.target === ui.modalBack) closeModal(); });
  window.addEventListener("keydown", (e) => { if(e.key === "Escape") closeModal(); });

  function mkBtn(text, cls, onClick){
    const b = document.createElement("button");
    b.textContent = text;
    if(cls) b.className = cls;
    b.addEventListener("click", onClick);
    return b;
  }

  function mkChoice(title, sub, onPick){
    const div = document.createElement("div");
    div.className = "choice";
    div.innerHTML = `<div class="cTitle">${escapeHtml(title)}</div><div class="cSub">${escapeHtml(sub)}</div>`;
    div.addEventListener("click", onPick);
    return div;
  }

  function heartDeltaRandom(){
    // 良い／悪いを明示しない微妙な揺れ
    const r = Math.random();
    if(r < 0.15) return -2;
    if(r < 0.50) return 0;
    if(r < 0.85) return 2;
    return 3;
  }

  function applyHeart(save, delta){
    const d = ensureDay(save, save.currentDay);
    const before = save.heart;
    save.heart = clamp(save.heart + delta, 0, 100);
    const realDelta = save.heart - before;
    d.heartChange += realDelta;
    d.heartEnd = save.heart;
  }

  function addChoice(save, category, choiceLabel){
    const d = ensureDay(save, save.currentDay);
    d.choices.push({
      t: now(),
      category,
      choice: choiceLabel
    });
  }

  function actFood(){
    const save = loadSave();
    if(!save) return;
    const elapsed = calcElapsedMs(save, now());
    if(!canInteract(save, elapsed)) return;

    const body = document.createElement("div");
    body.innerHTML = `<div style="font-size:12px;color:rgba(238,242,255,.78);line-height:1.7">
      どっちにする？<br>理由は説明しません。痕跡だけ残ります。
    </div>`;
    const two = document.createElement("div");
    two.className = "two";

    const pick = (label) => {
      const s = loadSave(); if(!s) return;
      const e = calcElapsedMs(s, now());
      if(!canInteract(s, e)) return;

      ensureDay(s, s.currentDay).careCounts.food++;
      addChoice(s, "食事", label);

      // 影響は小さく、ランダムも混ぜる（正解なし）
      let hungerChange = (label.includes("軽")) ? -18 : -30;
      let moodChange = (label.includes("しっかり")) ? 6 : 3;

      s.hunger = clamp(s.hunger + hungerChange + (Math.random()*4 - 2), 0, 100);
      s.mood   = clamp(s.mood + moodChange   + (Math.random()*4 - 2), 0, 100);

      const hd = heartDeltaRandom();
      applyHeart(s, hd);

      pushLiveLog(s, `食事を選んだ。`);
      saveSave(s);
      closeModal();
    };

    two.appendChild(mkChoice("軽い食事", "少しだけ、静かに。", () => pick("軽い食事")));
    two.appendChild(mkChoice("しっかりした食事", "長めに、ちゃんと。", () => pick("しっかりした食事")));

    body.appendChild(two);

    openModal("食事", "2択", body, [
      mkBtn("やめる", "btnGhost", closeModal)
    ]);
  }

  function actOut(){
    const save = loadSave();
    if(!save) return;
    const elapsed = calcElapsedMs(save, now());
    if(!canInteract(save, elapsed)) return;

    const body = document.createElement("div");
    body.innerHTML = `<div style="font-size:12px;color:rgba(238,242,255,.78);line-height:1.7">
      どっちの時間にする？
    </div>`;
    const two = document.createElement("div");
    two.className = "two";

    const pick = (label) => {
      const s = loadSave(); if(!s) return;
      const e = calcElapsedMs(s, now());
      if(!canInteract(s, e)) return;

      ensureDay(s, s.currentDay).careCounts.out++;
      addChoice(s, "お出かけ", label);

      // 影響は小さく、個体差のように揺れる
      if(label.includes("外")){
        s.mood = clamp(s.mood + 10 + (Math.random()*6 - 3), 0, 100);
        s.dirt = clamp(s.dirt + 6  + (Math.random()*4 - 2), 0, 100);
      }else{
        s.mood = clamp(s.mood + 4  + (Math.random()*6 - 3), 0, 100);
        s.dirt = clamp(s.dirt - 4  + (Math.random()*4 - 2), 0, 100);
      }

      applyHeart(s, heartDeltaRandom());
      pushLiveLog(s, `お出かけを選んだ。`);
      saveSave(s);
      closeModal();
    };

    two.appendChild(mkChoice("外に出る", "少し風に触れる。", () => pick("外に出る")));
    two.appendChild(mkChoice("家で過ごす", "近くにいる。", () => pick("家で過ごす")));

    body.appendChild(two);

    openModal("お出かけ", "2択", body, [
      mkBtn("やめる", "btnGhost", closeModal)
    ]);
  }

  function actMini(){
    const save = loadSave();
    if(!save) return;
    const elapsed = calcElapsedMs(save, now());
    if(!canInteract(save, elapsed)) return;

    const prompts = [
      ["左の星", "右の星", "どっちが気になる？"],
      ["丸い音", "角ばった音", "どっちが合いそう？"],
      ["明るい影", "暗い影", "どっちを置く？"],
      ["近い", "遠い", "どっちに寄る？"]
    ];
    const p = prompts[Math.floor(Math.random()*prompts.length)];

    const body = document.createElement("div");
    body.innerHTML = `<div style="font-size:12px;color:rgba(238,242,255,.78);line-height:1.7">
      ${escapeHtml(p[2])}<br>短い2択。すぐ終わります。
    </div>`;
    const two = document.createElement("div");
    two.className = "two";

    const pick = (label) => {
      const s = loadSave(); if(!s) return;
      const e = calcElapsedMs(s, now());
      if(!canInteract(s, e)) return;

      ensureDay(s, s.currentDay).careCounts.mini++;
      addChoice(s, "ミニゲーム", label);

      // 選択はほぼ意味を説明しない。ただ少し揺れる。
      s.mood = clamp(s.mood + 5 + (Math.random()*6 - 3), 0, 100);
      applyHeart(s, heartDeltaRandom());

      pushLiveLog(s, "短い遊びをした。");
      saveSave(s);
      closeModal();
    };

    two.appendChild(mkChoice(p[0], " ", () => pick(p[0])));
    two.appendChild(mkChoice(p[1], " ", () => pick(p[1])));

    body.appendChild(two);

    openModal("2択ミニゲーム", "2択", body, [
      mkBtn("やめる", "btnGhost", closeModal)
    ]);
  }

  function actClean(){
    const save = loadSave();
    if(!save) return;
    const elapsed = calcElapsedMs(save, now());
    if(!canInteract(save, elapsed)) return;

    const body = document.createElement("div");
    body.innerHTML = `<div style="font-size:12px;color:rgba(238,242,255,.78);line-height:1.7">
      まずやり方を選んで、出ているものをタップして消します。<br>
      放置すると、ゆっくり状態が悪化します。
    </div>`;

    const two = document.createElement("div");
    two.className = "two";

    const startClean = (modeLabel) => {
      // クリック掃除パート（ゲームっぽいが、入口は2択）
      const s0 = loadSave(); if(!s0) return;
      const e0 = calcElapsedMs(s0, now());
      if(!canInteract(s0, e0)) return;

      closeModal();

      const s = loadSave();
      if(!s) return;

      const need = Math.max(1, s.poop);
      let remaining = need;

      const overlay = document.createElement("div");
      overlay.style.position = "fixed";
      overlay.style.inset = "0";
      overlay.style.background = "rgba(0,0,0,.55)";
      overlay.style.zIndex = "120";
      overlay.style.display = "grid";
      overlay.style.placeItems = "center";
      overlay.style.padding = "18px";

      const box = document.createElement("div");
      box.style.width = "min(560px, 96vw)";
      box.style.border = "1px solid rgba(255,255,255,.16)";
      box.style.background = "rgba(16,18,34,.88)";
      box.style.borderRadius = "18px";
      box.style.boxShadow = "0 22px 60px rgba(0,0,0,.45)";
      box.style.padding = "12px";
      box.style.backdropFilter = "blur(12px)";

      const head = document.createElement("div");
      head.style.display = "flex";
      head.style.justifyContent = "space-between";
      head.style.gap = "10px";
      head.style.alignItems = "center";
      head.innerHTML = `<div>
        <div style="font-weight:800;font-size:14px">排泄除去</div>
        <div style="font-size:12px;color:rgba(238,242,255,.72);margin-top:4px">タップして消す（残り ${remaining}）</div>
      </div>`;
      const cancel = mkBtn("やめる", "btnGhost", () => {
        document.body.removeChild(overlay);
      });
      cancel.style.padding = "8px 10px";
      head.appendChild(cancel);

      const field = document.createElement("div");
      field.style.marginTop = "10px";
      field.style.display = "flex";
      field.style.flexWrap = "wrap";
      field.style.gap = "10px";
      field.style.justifyContent = "center";

      function mkPoopChip(){
        const chip = document.createElement("div");
        chip.style.width = "64px";
        chip.style.height = "64px";
        chip.style.borderRadius = "18px";
        chip.style.border = "1px solid rgba(255,255,255,.12)";
        chip.style.background = "linear-gradient(180deg, rgba(251,146,60,.92), rgba(234,179,8,.82))";
        chip.style.boxShadow = "0 12px 24px rgba(0,0,0,.25)";
        chip.style.cursor = "pointer";
        chip.style.transform = `rotate(${(Math.random()*18-9).toFixed(1)}deg)`;
        chip.title = " ";
        chip.addEventListener("click", () => {
          chip.style.opacity = ".0";
          chip.style.pointerEvents = "none";
          remaining--;
          head.querySelector("div div:nth-child(2)").textContent = `タップして消す（残り ${Math.max(0, remaining)}）`;
          if(remaining <= 0){
            // 終了処理
            const s1 = loadSave(); if(!s1) return;
            const e1 = calcElapsedMs(s1, now());
            if(!canInteract(s1, e1)) return;

            ensureDay(s1, s1.currentDay).careCounts.clean++;
            addChoice(s1, "排泄除去", modeLabel);

            // 効果は方法で少し差があるが、理由は言わない
            const careful = modeLabel.includes("ていねい");
            const dirtDown = careful ? 26 : 16;
            const moodUp   = careful ? 10 : 6;

            s1.poop = 0;
            s1.dirt = clamp(s1.dirt - dirtDown + (Math.random()*4 - 2), 0, 100);
            s1.mood = clamp(s1.mood + moodUp   + (Math.random()*4 - 2), 0, 100);

            applyHeart(s1, heartDeltaRandom());
            pushLiveLog(s1, "きれいにした。");
            saveSave(s1);

            document.body.removeChild(overlay);
          }
        });
        return chip;
      }

      for(let i=0;i<need;i++){
        field.appendChild(mkPoopChip());
      }

      const note = document.createElement("div");
      note.style.marginTop = "10px";
      note.style.fontSize = "12px";
      note.style.color = "rgba(238,242,255,.72)";
      note.style.lineHeight = "1.7";
      note.textContent = "終わったら自動で戻ります。";

      box.appendChild(head);
      box.appendChild(field);
      box.appendChild(note);
      overlay.appendChild(box);
      document.body.appendChild(overlay);
    };

    two.appendChild(mkChoice("ていねいに掃除", "少し時間をかける。", () => startClean("ていねいに掃除")));
    two.appendChild(mkChoice("さっと掃除", "急いで済ませる。", () => startClean("さっと掃除")));

    body.appendChild(two);

    openModal("排泄除去", "2択 + 短いタップ", body, [
      mkBtn("やめる", "btnGhost", closeModal)
    ]);
  }

  function actDrink(){
    const save = loadSave();
    if(!save) return;

    const elapsed = calcElapsedMs(save, now());
    if(!save.hatched) return;

    // 生存中のみ
    if(save.ended || save.macaronActive) return;

    const body = document.createElement("div");
    body.innerHTML = `<div style="font-size:12px;color:rgba(238,242,255,.78);line-height:1.7">
      ドリンクを使う？<br>
      少しだけ時間や状態が戻る／延びることがあります。理由は説明しません。<br>
      使用はログに残ります。
    </div>`;

    const two = document.createElement("div");
    two.className = "two";

    const use = () => {
      const s = loadSave(); if(!s) return;
      const e = calcElapsedMs(s, now());
      if(s.ended || s.macaronActive) return;
      if(!s.hatched) return;

      const d = ensureDay(s, s.currentDay);
      d.items.drink++;
      addChoice(s, "ドリンク", "使う");

      // 状態を少し戻す
      s.hunger = clamp(s.hunger - 12 + (Math.random()*4 - 2), 0, 100);
      s.dirt   = clamp(s.dirt   - 10 + (Math.random()*4 - 2), 0, 100);
      s.mood   = clamp(s.mood   +  8 + (Math.random()*4 - 2), 0, 100);

      // 寿命を少し延ばす
      s.lifeExtensionMs = (s.lifeExtensionMs || 0) + DRINK_LIFE_EXTEND_MS;

      // さらに「少し戻す」感：今までの経過を少し巻き戻す
      // 直接elapsedを戻す代わりに、開始時刻を未来へずらす
      // これにより内部の寿命・空腹・排泄の進行も少し戻る
      s.startedAt += DRINK_BACK_MS;

      applyHeart(s, 0);
      pushLiveLog(s, "ドリンクを使った。");
      saveSave(s);
      closeModal();
    };

    two.appendChild(mkChoice("使う", "ほんの少し。", use));
    two.appendChild(mkChoice("使わない", "今回は見送る。", () => { addChoice(save, "ドリンク", "やめる"); closeModal(); }));

    body.appendChild(two);

    openModal("ドリンク", "生存中のみ", body, [
      mkBtn("閉じる", "btnGhost", closeModal)
    ]);
  }

  function actMacaron(){
    const save = loadSave();
    if(!save) return;

    // 死後のみ
    if(!save.ended || save.macaronActive) return;

    const body = document.createElement("div");
    body.innerHTML = `<div style="font-size:12px;color:rgba(238,242,255,.78);line-height:1.7">
      マカロンを使う？<br>
      一時的に戻るかもしれませんが、完全ではありません。<br>
      使用はログに残ります。
    </div>`;

    const two = document.createElement("div");
    two.className = "two";

    const use = () => {
      const s = loadSave(); if(!s) return;
      if(!s.ended || s.macaronActive) return;

      const e = calcElapsedMs(s, now());
      const d = ensureDay(s, s.currentDay);
      d.items.macaron++;
      addChoice(s, "マカロン", "使う");

      // 一時復活: uncanny
      s.macaronActive = true;
      s.macaronEndsAtElapsed = e + MACARON_MS;

      // 少しだけ戻るが、違和感が残る（完全回復ではない）
      s.ended = false;
      s.hunger = clamp(s.hunger - 8 + (Math.random()*6 - 3), 0, 100);
      s.dirt   = clamp(s.dirt   - 6 + (Math.random()*6 - 3), 0, 100);
      s.mood   = clamp(s.mood   + 2 + (Math.random()*6 - 3), 0, 100);
      // ハートは強調しないが、揺れとして少し下がることもある
      applyHeart(s, Math.random() < 0.55 ? -2 : 0);

      pushLiveLog(s, "戻ってきた。");
      saveSave(s);
      closeModal();
    };

    two.appendChild(mkChoice("使う", "一時的に。", use));
    two.appendChild(mkChoice("使わない", "見送る。", () => { addChoice(save, "マカロン", "やめる"); closeModal(); }));

    body.appendChild(two);

    openModal("マカロン", "死後のみ", body, [
      mkBtn("閉じる", "btnGhost", closeModal)
    ]);
  }

  function showLogs(save){
    const exp = exportObservationData(save);
    showObserve(exp, false);
  }

  function exportObservationData(save){
    // 観察者に見せるのはログとハート推移だけ
    const days = [];
    for(let i=1;i<=3;i++){
      const d = ensureDay(save, i);
      const lines = (d.choices || []).map(c => `・${formatClock(c.t)} ${c.category}：${c.choice}`).join("\n");
      days.push({
        day: i,
        careCounts: d.careCounts,
        heartChange: d.heartChange,
        sitterMs: d.sitterMs,
        items: d.items,
        choicesText: lines,
        heartStart: d.heartStart,
        heartEnd: d.heartEnd
      });
    }
    return {
      version: 1,
      playerId: save.playerId,
      startedAt: save.startedAt,
      endedAt: save.endedAt || null,
      days
    };
  }

  function toBase64Url(str){
    const b64 = btoa(unescape(encodeURIComponent(str)));
    return b64.replace(/\+/g,"-").replace(/\//g,"_").replace(/=+$/,"");
  }
  function fromBase64Url(b64url){
    const b64 = b64url.replace(/-/g,"+").replace(/_/g,"/");
    const pad = b64.length % 4 ? "=".repeat(4 - (b64.length % 4)) : "";
    const s = atob(b64 + pad);
    return decodeURIComponent(escape(s));
  }

  function makeShareUrl(save){
    const exp = exportObservationData(save);
    const data = toBase64Url(JSON.stringify(exp));
    // 同じindex.htmlで観察モードにする
    const u = new URL(location.href);
    u.searchParams.set("observe","1");
    u.hash = "data=" + data;
    return u.toString();
  }

  async function copyText(text){
    try{
      await navigator.clipboard.writeText(text);
      return true;
    }catch(e){
      // フォールバック
      const ta = document.createElement("textarea");
      ta.value = text;
      document.body.appendChild(ta);
      ta.select();
      try{
        document.execCommand("copy");
        document.body.removeChild(ta);
        return true;
      }catch(err){
        document.body.removeChild(ta);
        return false;
      }
    }
  }

  function showShare(save){
    const shareUrl = makeShareUrl(save);

    const body = document.createElement("div");
    body.innerHTML = `<div style="font-size:12px;color:rgba(238,242,255,.78);line-height:1.7">
      このURLを共有すると、第三者は「観察用ログ画面」だけを閲覧できます。<br>
      操作はできません。見えるのはログとハート推移のみです。
    </div>`;

    const box = document.createElement("div");
    box.style.marginTop = "10px";
    box.style.border = "1px solid rgba(255,255,255,.14)";
    box.style.background = "rgba(255,255,255,.04)";
    box.style.borderRadius = "14px";
    box.style.padding = "10px";
    box.style.fontSize = "12px";
    box.style.color = "rgba(238,242,255,.9)";
    box.style.wordBreak = "break-all";
    box.textContent = shareUrl;

    body.appendChild(box);

    const bCopy = mkBtn("コピー", "", async () => {
      const ok = await copyText(shareUrl);
      const s = loadSave();
      if(s){
        pushLiveLog(s, ok ? "URLをコピーした。" : "URLを表示した。");
        saveSave(s);
      }
      closeModal();
    });

    openModal("観察用URL", "共有するとログだけ見られます", body, [
      mkBtn("閉じる", "btnGhost", closeModal),
      bCopy
    ]);
  }

  function showSaveHint(){
    const body = document.createElement("div");
    body.innerHTML = `<div style="font-size:12px;color:rgba(238,242,255,.78);line-height:1.8">
      このプロトタイプは localStorage に保存します。<br>
      ブラウザを閉じても続きから再開できます。<br>
      シッターをONにすると、寿命・空腹・排泄・状態変化が止まります（使用時間はログに残ります）。<br>
      観察用URLは、ログとハート推移のみが見える形でデータをURLに含めます。
    </div>`;
    openModal("保存について", " ", body, [
      mkBtn("閉じる", "btnGhost", closeModal)
    ]);
  }

  function confirmReset(){
    const body = document.createElement("div");
    body.innerHTML = `<div style="font-size:12px;color:rgba(238,242,255,.78);line-height:1.8">
      はじめから遊べます。<br>
      どちらにしても評価や点数は出ません。<br>
      ログは痕跡として残すか、消すか選べます。
    </div>`;
    const two = document.createElement("div");
    two.className = "two";

    const keep = () => {
      // いまのセーブはアーカイブに残し、新規セーブに
      const s = loadSave();
      if(s) archiveRun(s);
      const n = createNewSave();
      saveSave(n);
      pushLiveLog(n, "始まった。");
      closeModal();
    };
    const wipe = () => {
      localStorage.removeItem(SAVE_KEY);
      const n = createNewSave();
      saveSave(n);
      pushLiveLog(n, "始まった。");
      closeModal();
    };

    two.appendChild(mkChoice("ログを残してはじめる", "過去の痕跡はアーカイブへ。", keep));
    two.appendChild(mkChoice("ログを消してはじめる", "この端末の記録を消します。", wipe));
    body.appendChild(two);

    openModal("はじめから", " ", body, [
      mkBtn("やめる", "btnGhost", closeModal)
    ]);
  }

  function showObserve(exp, fromUrl){
    ui.screenGame.classList.remove("show");
    ui.screenObserve.classList.add("show");

    const start = new Date(exp.startedAt);
    const end = exp.endedAt ? new Date(exp.endedAt) : null;

    ui.obsTitle.textContent = `観察ID：${exp.playerId.slice(0,8)}`;
    ui.obsSub.textContent = end
      ? `${start.toLocaleString()} 〜 ${end.toLocaleString()}`
      : `${start.toLocaleString()} 〜 （進行中）`;

    // 日別カード
    ui.obsDays.innerHTML = "";
    exp.days.forEach(d => {
      const card = document.createElement("div");
      card.className = "dayCard";
      const sitterMin = Math.round((d.sitterMs || 0) / 60000);
      const c = d.careCounts || {food:0,out:0,mini:0,clean:0};
      const it = d.items || {drink:0,macaron:0};

      card.innerHTML = `
        <div class="dh">
          <b>Day ${d.day}</b>
          <small> </small>
        </div>
        <div class="kvs">
          <div><span>食事</span> ${c.food}</div>
          <div><span>お出かけ</span> ${c.out}</div>
          <div><span>ミニゲーム</span> ${c.mini}</div>
          <div><span>排泄除去</span> ${c.clean}</div>
          <div><span>ハートの変化</span> ${d.heartChange}</div>
          <div><span>シッター</span> ${sitterMin} 分</div>
          <div><span>ドリンク</span> ${it.drink}</div>
          <div><span>マカロン</span> ${it.macaron}</div>
        </div>
        <div class="choices">${escapeHtml(d.choicesText || "（記録なし）")}</div>
      `;
      ui.obsDays.appendChild(card);
    });

    drawHeartChart(exp);

    if(fromUrl){
      ui.btnBackToGame.textContent = "閉じる";
    }else{
      ui.btnBackToGame.textContent = "戻る";
    }
  }

  function drawHeartChart(exp){
    const canvas = ui.heartChart;
    const ctx = canvas.getContext("2d");

    // 高DPI
    const dpr = Math.max(1, Math.floor(window.devicePixelRatio || 1));
    const cssW = canvas.clientWidth || 900;
    const cssH = 160;
    canvas.width = Math.floor(cssW * dpr);
    canvas.height = Math.floor(cssH * dpr);
    ctx.scale(dpr, dpr);

    const w = cssW, h = cssH;
    ctx.clearRect(0,0,w,h);

    // 余白
    const padL = 34, padR = 12, padT = 12, padB = 22;

    // 軸
    ctx.lineWidth = 1;
    ctx.strokeStyle = "rgba(255,255,255,.14)";
    ctx.beginPath();
    ctx.moveTo(padL, padT);
    ctx.lineTo(padL, h - padB);
    ctx.lineTo(w - padR, h - padB);
    ctx.stroke();

    // 目盛り
    ctx.fillStyle = "rgba(238,242,255,.65)";
    ctx.font = "12px system-ui, -apple-system, sans-serif";
    ctx.fillText("100", 6, padT + 10);
    ctx.fillText("0", 14, h - padB + 4);

    // データ点（day end）
    const pts = exp.days.map((d, i) => ({
      x: i,
      y: clamp(d.heartEnd ?? 50, 0, 100)
    }));

    const xSpan = Math.max(1, pts.length - 1);
    const plotW = (w - padL - padR);
    const plotH = (h - padT - padB);

    function pxX(x){ return padL + (x / xSpan) * plotW; }
    function pxY(y){ return padT + (1 - y/100) * plotH; }

    // 線
    ctx.strokeStyle = "rgba(196,181,253,.92)";
    ctx.lineWidth = 2;
    ctx.beginPath();
    pts.forEach((p, i) => {
      const x = pxX(p.x);
      const y = pxY(p.y);
      if(i === 0) ctx.moveTo(x,y);
      else ctx.lineTo(x,y);
    });
    ctx.stroke();

    // 点
    ctx.fillStyle = "rgba(147,197,253,.92)";
    pts.forEach(p => {
      const x = pxX(p.x);
      const y = pxY(p.y);
      ctx.beginPath();
      ctx.arc(x,y, 3.5, 0, Math.PI*2);
      ctx.fill();
    });

    // day labels
    ctx.fillStyle = "rgba(238,242,255,.72)";
    exp.days.forEach((d,i) => {
      const x = pxX(i);
      ctx.fillText("D" + d.day, x - 8, h - 6);
    });
  }

  function enterObserveFromUrl(){
    const u = new URL(location.href);
    const observe = u.searchParams.get("observe") === "1";
    if(!observe) return false;

    let data = "";
    if(location.hash && location.hash.startsWith("#data=")){
      data = location.hash.slice(6);
    }
    if(!data){
      // dataがない場合、観察画面だけ開く
      const body = document.createElement("div");
      body.innerHTML = `<div style="font-size:12px;color:rgba(238,242,255,.78);line-height:1.8">
        観察用データが見つかりませんでした。<br>
        共有URLをそのまま開いているか確認してください。
      </div>`;
      openModal("観察", " ", body, [mkBtn("閉じる", "btnGhost", () => { closeModal(); })]);
      return true;
    }

    try{
      const json = fromBase64Url(data);
      const exp = JSON.parse(json);
      if(!exp || exp.version !== 1) throw new Error("bad");
      showObserve(exp, true);
      return true;
    }catch(e){
      const body = document.createElement("div");
      body.innerHTML = `<div style="font-size:12px;color:rgba(238,242,255,.78);line-height:1.8">
        観察用データの読み込みに失敗しました。<br>
        URLが途中で切れている可能性があります。
      </div>`;
      openModal("観察", " ", body, [mkBtn("閉じる", "btnGhost", closeModal)]);
      return true;
    }
  }

  function boot(){
    // 観察URLなら先に観察画面
    if(enterObserveFromUrl()){
      return;
    }

    let save = loadSave();
    if(!save){
      save = createNewSave();
      saveSave(save);
      pushLiveLog(save, "始まった。");
      saveSave(save);
    }

    // 画像が無い場合でも動くように（imgは未使用だが、差し替え用に残す）
    ui.eggImg.addEventListener("error", () => {
      // 画像が無いときは何もしない（ラップ背景が卵っぽく見える）
    });

    // UIイベント
    ui.btnFood.addEventListener("click", actFood);
    ui.btnOut.addEventListener("click", actOut);
    ui.btnMini.addEventListener("click", actMini);
    ui.btnClean.addEventListener("click", actClean);
    ui.btnDrink.addEventListener("click", actDrink);
    ui.btnMacaron.addEventListener("click", actMacaron);

    ui.btnShare.addEventListener("click", () => {
      const s = loadSave(); if(!s) return;
      showShare(s);
    });
    ui.btnLogs.addEventListener("click", () => {
      const s = loadSave(); if(!s) return;
      showLogs(s);
    });
    ui.btnReset.addEventListener("click", confirmReset);
    ui.btnSaveHint.addEventListener("click", showSaveHint);

    ui.btnBackToGame.addEventListener("click", () => {
      // 観察URLから開いている場合は、ゲーム画面に戻らず閉じる感覚に
      const u = new URL(location.href);
      const observe = u.searchParams.get("observe") === "1";
      if(observe){
        // ハッシュとパラメータを外して同じページを開く
        u.searchParams.delete("observe");
        u.hash = "";
        location.href = u.toString();
        return;
      }
      ui.screenObserve.classList.remove("show");
      ui.screenGame.classList.add("show");
    });

    ui.sitterToggle.addEventListener("click", () => {
      const s = loadSave(); if(!s) return;
      if(!s.pausedSince){
        // ON
        s.pausedSince = now();
        pushLiveLog(s, "預けた。");
        saveSave(s);
      }else{
        // OFF
        const t = now();
        const pausedDur = t - s.pausedSince;
        s.totalPausedMs += pausedDur;

        // シッター使用時間は当日ログへ（実時間）
        const d = ensureDay(s, s.currentDay);
        d.sitterMs += pausedDur;

        s.pausedSince = null;
        pushLiveLog(s, "戻った。");
        saveSave(s);
      }
    });

    // ループ
    setInterval(() => {
      const s = loadSave();
      if(!s) return;

      const t = now();
      const elapsed = calcElapsedMs(s, t);

      // 日更新
      updateDayBoundary(s, elapsed);

      // 時間シミュレーション
      if(!s.pausedSince){
        applyTimeSimulation(s, elapsed);
      }

      // 孵化
      if(!s.pausedSince){
        maybeHatch(s, elapsed);
      }

      // マカロン復活の終了
      if(!s.pausedSince){
        updateMacaronTimer(s, elapsed);
      }

      // 3日終了
      if(!s.pausedSince){
        maybeEnd(s, elapsed);
      }

      s.lastSimElapsed = elapsed;
      saveSave(s);
      render(s);
    }, 650);

    // 初回描画
    render(save);
  }

  boot();
})();
</script>
</body>
</html>
