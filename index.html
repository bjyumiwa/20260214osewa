<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>3日間のお世話ゲーム</title>
  <style>
    :root{
      --bg:#f6f7fb; --card:#ffffff; --text:#111827; --muted:#6b7280; --line:#e5e7eb;
      --shadow: 0 10px 30px rgba(17,24,39,.10);
      --radius: 18px;

      /* 生まれてくる子のサイズ（ここで調整） */
      --newborn-size: 110px;    /* 誕生直後 */
      --grow-min: .52;          /* お世話開始直後の小ささ */
      --grow-max: .96;          /* 終盤の大きさ */
    }

    *{ box-sizing:border-box; }
    body{
      margin:0;
      font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Yu Gothic", "Meiryo", sans-serif;
      background: radial-gradient(1200px 500px at 50% 0%, #ffffff 0%, var(--bg) 60%, #eef2ff 100%);
      color:var(--text);
    }

    .wrap{ max-width: 980px; margin:0 auto; padding: 18px; }

    .topbar{
      display:flex; gap:12px; align-items:center; justify-content:space-between;
      padding: 14px 16px; border:1px solid var(--line); background: rgba(255,255,255,.75);
      backdrop-filter: blur(8px);
      border-radius: var(--radius); box-shadow: var(--shadow);
      position: sticky; top: 10px; z-index: 5;
    }
    .title{ display:flex; flex-direction:column; gap:4px; }
    .title .small{ color:var(--muted); font-size: 12px; }

    .hearts{ display:flex; align-items:center; gap:10px; }
    .heartRow{ display:flex; gap:4px; align-items:center; }
    .h{
      width: 12px; height: 12px; transform: rotate(45deg);
      background: #fca5a5; border-radius: 2px; position: relative; opacity:.40;
    }
    .h::before,.h::after{ content:""; position:absolute; width: 12px; height:12px; background: inherit; border-radius: 50%; }
    .h::before{ left:-6px; top:0; }
    .h::after{ top:-6px; left:0; }
    .h.on{ opacity: .95; background:#fb7185; }

    .pill{
      display:inline-flex; align-items:center; gap:8px;
      padding: 8px 10px; border-radius: 999px; border:1px solid var(--line);
      background: rgba(255,255,255,.8);
      font-size: 12px; color: var(--muted);
      user-select:none;
    }
    .dot{
      width:10px; height:10px; border-radius: 50%;
      background: #10b981;
      box-shadow: 0 0 0 4px rgba(16,185,129,.15);
    }
    .dot.pause{ background:#f59e0b; box-shadow: 0 0 0 4px rgba(245,158,11,.15); }

    .grid{ margin-top: 14px; display:grid; grid-template-columns: 1.2fr .8fr; gap: 12px; }
    @media (max-width: 860px){ .grid{ grid-template-columns: 1fr; } }

    .card{
      border:1px solid var(--line);
      border-radius: var(--radius);
      background: rgba(255,255,255,.85);
      backdrop-filter: blur(8px);
      box-shadow: var(--shadow);
      overflow:hidden;
    }
    .cardHead{
      padding: 14px 16px;
      border-bottom: 1px solid var(--line);
      display:flex; justify-content:space-between; align-items:center;
      gap: 12px;
    }
    .cardHead .sub{ color:var(--muted); font-size: 12px; }
    .cardBody{ padding: 16px; }

    .btn{
      border:1px solid var(--line);
      background: #ffffff;
      color: var(--text);
      border-radius: 14px;
      padding: 12px 12px;
      display:flex; align-items:center; justify-content:space-between;
      cursor:pointer;
      transition: transform .06s ease, box-shadow .2s ease;
      box-shadow: 0 8px 18px rgba(17,24,39,.06);
      user-select:none;
    }
    .btn:hover{ box-shadow: 0 10px 22px rgba(17,24,39,.10); }
    .btn:active{ transform: translateY(1px); }
    .btn.primary{
      background: linear-gradient(180deg, rgba(47,111,237,1) 0%, rgba(37,99,235,1) 100%);
      border-color: rgba(37,99,235,.55);
      color:#fff;
    }
    .btn.dark{ background: #111827; border-color: rgba(17,24,39,.7); color:#fff; }
    .btn.danger{ background: #fff1f2; border-color: rgba(225,29,72,.25); color: #9f1239; }
    .btn.small{ padding: 9px 10px; border-radius: 999px; font-size: 12px; box-shadow:none; }
    .btnRow{ display:flex; gap: 8px; flex-wrap:wrap; align-items:center; justify-content:flex-end; }

    .actions{ display:grid; grid-template-columns: 1fr 1fr; gap: 10px; }

    .logBox{
      border:1px dashed rgba(107,114,128,.35);
      border-radius: 14px;
      padding: 12px;
      background: rgba(255,255,255,.6);
      max-height: 360px;
      overflow:auto;
      font-size: 12px;
      color: #111827;
      line-height: 1.45;
      white-space: pre-wrap;
    }
    .muted{ color: var(--muted); }

    .stage{
      min-height: 420px;
      display:flex; align-items:center; justify-content:center;
      position: relative;
      overflow:hidden;
    }
    .stage::before{
      content:"";
      position:absolute; inset:-40px;
      background:
        radial-gradient(600px 260px at 50% 30%, rgba(99,102,241,.12), transparent 60%),
        radial-gradient(420px 260px at 35% 80%, rgba(236,72,153,.08), transparent 60%),
        radial-gradient(420px 260px at 65% 80%, rgba(59,130,246,.08), transparent 60%);
      pointer-events:none;
    }

    /* ホーム（必ず出す） */
    .homeGate{
      position:absolute; inset:0;
      display:none;
      align-items:center; justify-content:center;
      z-index: 20;
      background: rgba(255,255,255,.78);
      backdrop-filter: blur(10px);
      padding: 16px;
    }
    .homeGate.show{ display:flex; }

    .homeCard{
      width:min(560px, 100%);
      border-radius: 20px;
      border:1px solid rgba(229,231,235,.95);
      background: rgba(255,255,255,.92);
      box-shadow: 0 24px 60px rgba(17,24,39,.18);
      padding: 18px;
    }
    .homeTitle{ font-size: 18px; font-weight: 750; letter-spacing: .02em; }
    .homeText{
      margin-top: 10px;
      color: var(--muted);
      font-size: 13px;
      line-height: 1.7;
    }
    .pickRow{ margin-top: 12px; display:flex; gap:10px; flex-wrap:wrap; }
    .pick{
      flex:1;
      min-width: 110px;
      border-radius: 16px;
      border:1px solid rgba(229,231,235,.95);
      background: rgba(255,255,255,.86);
      padding: 10px;
      cursor:pointer;
      user-select:none;
      transition: transform .06s ease, box-shadow .2s ease, border-color .2s ease;
      display:flex; align-items:center; justify-content:center;
      gap: 8px;
      font-size: 13px;
      color: rgba(17,24,39,.86);
    }
    .pick:active{ transform: translateY(1px); }
    .pick.on{ border-color: rgba(37,99,235,.45); box-shadow: 0 10px 24px rgba(37,99,235,.12); }
    .swatch{
      width: 14px; height: 14px; border-radius: 999px;
      box-shadow: inset 0 0 0 2px rgba(255,255,255,.85), 0 8px 18px rgba(17,24,39,.10);
    }

    .homeBtns{ margin-top: 14px; display:flex; gap:10px; flex-wrap:wrap; justify-content:flex-end; }

    /* マカロン演出 */
    .macaronWrap{
      width: 220px;
      display:flex; align-items:center; justify-content:center;
      position: relative;
      z-index: 1;
      filter: drop-shadow(0 18px 22px rgba(17,24,39,.18));
      animation: floaty 3.2s ease-in-out infinite;
    }
    .macaronWrap.fading{ animation: none; }
    .macaronImg{ width: 100%; height:auto; user-select:none; -webkit-user-drag:none; }

    .newborn{
      position:absolute;
      width: var(--newborn-size);
      opacity:0;
      transform: translateY(12px) scale(.84);
      filter: drop-shadow(0 16px 18px rgba(17,24,39,.14));
      user-select:none;
      -webkit-user-drag:none;
    }
    .macaronFade{
      animation: macaronFade 2.6s ease forwards;
    }
    .newbornReveal{
      animation: newbornReveal 2.6s ease forwards;
    }

    @keyframes floaty{ 0%,100%{ transform: translateY(0); } 50%{ transform: translateY(-10px); } }
    @keyframes macaronFade{
      0%{ opacity:1; transform: translateY(0) scale(1); }
      60%{ opacity:.45; transform: translateY(-6px) scale(.995); }
      100%{ opacity:0; transform: translateY(-12px) scale(.99); }
    }
    @keyframes newbornReveal{
      0%{ opacity:0; transform: translateY(14px) scale(.84); }
      35%{ opacity:.35; }
      100%{ opacity:1; transform: translateY(0) scale(1); }
    }

    /* 誕生後：2人横並び */
    .petRow{
      display:flex;
      align-items:flex-end;
      justify-content:center;
      gap: 22px;
      z-index: 1;
      padding: 10px 0;
    }
    .petSlot{
      width: 160px;
      height: 160px;
      display:flex; align-items:center; justify-content:center;
      position: relative;
      filter: drop-shadow(0 18px 22px rgba(17,24,39,.18));
      user-select:none;
      -webkit-user-drag:none;
    }
    .petImg{
      width: 100%;
      height:auto;
      user-select:none;
      -webkit-user-drag:none;
      transform-origin: 50% 100%;
    }

    /* 状態はラベルで言わず、動きだけ */
    .mood-good .petImg{ animation: bop 1.6s ease-in-out infinite; }
    .mood-low  .petImg{ animation: sway 3.2s ease-in-out infinite; opacity:.95; }
    .mood-cry  .petImg{ animation: tremble .28s ease-in-out infinite; opacity:.90; }

    .mood-cry .petSlot::after{
      content:"";
      position:absolute;
      width: 10px; height: 14px;
      right: 18%;
      top: 48%;
      background: rgba(59,130,246,.55);
      border-radius: 8px 8px 10px 10px;
      transform: rotate(10deg);
      filter: blur(.2px);
      animation: drip 1.3s ease-in-out infinite;
    }

    .weird{ animation: glitch 2.2s steps(2,end) infinite; }

    @keyframes bop{ 0%,100%{ transform: translateY(0) scale(1); } 50%{ transform: translateY(-10px) scale(1.02); } }
    @keyframes sway{ 0%,100%{ transform: translateX(0) rotate(0deg); } 50%{ transform: translateX(3px) rotate(1.4deg); } }
    @keyframes tremble{ 0%,100%{ transform: translateX(0) rotate(0deg); } 50%{ transform: translateX(2px) rotate(-.8deg); } }
    @keyframes drip{
      0%,100%{ transform: translateY(0) rotate(10deg); opacity:.55; }
      60%{ transform: translateY(8px) rotate(10deg); opacity:.25; }
    }
    @keyframes glitch{
      0%{ filter: hue-rotate(0deg) saturate(1); transform: translate(0,0); }
      10%{ filter: hue-rotate(12deg) saturate(1.1); transform: translate(1px,-1px); }
      20%{ filter: hue-rotate(0deg) saturate(1); transform: translate(-1px,1px); }
      30%{ filter: hue-rotate(-10deg) saturate(1.15); transform: translate(1px,0); }
      40%{ filter: hue-rotate(0deg) saturate(1); transform: translate(0,0); }
      100%{ filter: hue-rotate(0deg) saturate(1); transform: translate(0,0); }
    }

    .imgPlaceholder{
      width: 100%;
      height: 100%;
      border-radius: 22px;
      border: 1px solid rgba(229,231,235,.9);
      background: rgba(17,24,39,.06);
      display:flex;
      align-items:center;
      justify-content:center;
      color: rgba(107,114,128,.85);
      font-size: 12px;
      padding: 10px;
      text-align:center;
    }

    /* ありがとう＋再スタート */
    .thanks{
      position:absolute; inset:0;
      display:none;
      align-items:center; justify-content:center;
      z-index: 18;
      background: rgba(255,255,255,.80);
      backdrop-filter: blur(8px);
      padding: 16px;
    }
    .thanks.show{ display:flex; }
    .thanksBox{
      width:min(560px, 100%);
      border-radius: 20px;
      border:1px solid rgba(229,231,235,.95);
      background: rgba(255,255,255,.92);
      box-shadow: 0 24px 60px rgba(17,24,39,.18);
      padding: 18px;
      text-align:center;
    }
    .thanksWord{
      font-size: 34px;
      letter-spacing: .12em;
      font-weight: 800;
      color: rgba(17,24,39,.88);
      margin-top: 8px;
    }
    .thanksBtns{
      margin-top: 14px;
      display:flex;
      gap: 10px;
      flex-wrap:wrap;
      justify-content:center;
    }
    .tiny{ font-size:12px; color: var(--muted); line-height: 1.6; margin-top: 10px; }

  </style>
</head>

<body>
  <div class="wrap">
    <div class="topbar">
      <div class="title">
        <div style="font-weight:700;">3日間のお世話ゲーム</div>
        <div class="small" id="modeLabel">あなたの選択が残ります</div>
      </div>

      <div class="hearts">
        <div class="pill" title="シッターONで時間停止">
          <span class="dot" id="sitterDot"></span>
          <span id="sitterText">進行中</span>
        </div>
        <div class="heartRow" id="heartRow" aria-label="ハート"></div>
      </div>
    </div>

    <div class="grid">
      <div class="card">
        <div class="cardHead">
          <div>
            <div style="font-weight:650;">いま</div>
            <div class="sub" id="subHint">状態は言葉にしません</div>
          </div>
          <div class="btnRow">
            <button class="btn small" id="btnHome">ホーム</button>
            <button class="btn small" id="btnSitter">シッター</button>
            <button class="btn small" id="btnShare">共有</button>
            <button class="btn small danger" id="btnReset">全部消す</button>
          </div>
        </div>

        <div class="stage" id="stage">
          <!-- ホーム -->
          <div class="homeGate" id="homeGate">
            <div class="homeCard">
              <div class="homeTitle" id="homeTitle">はじめる</div>
              <div class="homeText" id="homeText">
                しばらくすると、マカロンが薄くなり、生まれます。<br>
                正解や評価はありません。選んだことだけが残ります。
              </div>

              <div style="margin-top:12px; font-size:12px; color:var(--muted);">あなたの色</div>
              <div class="pickRow" id="colorPicks"></div>

              <div class="homeBtns">
                <button class="btn secondary" id="btnContinue">続きから</button>
                <button class="btn primary" id="btnStart">最初から</button>
              </div>

              <div class="tiny" id="homeTiny"></div>
            </div>
          </div>

          <!-- ありがとう＋再スタート -->
          <div class="thanks" id="thanks">
            <div class="thanksBox">
              <div class="thanksWord">ありがとう</div>
              <div class="tiny">
                ここから、次の周回を選べます。
              </div>
              <div class="thanksBtns">
                <button class="btn primary" id="btnRestartLog">ログを残して最初から</button>
                <button class="btn dark" id="btnRestartKeep">姿を引き継いで最初から</button>
                <button class="btn secondary" id="btnEndToHome">ホームへ</button>
              </div>
            </div>
          </div>

          <!-- マカロン（誕生前） -->
          <div class="macaronWrap" id="macaronWrap" style="display:none;">
            <img class="macaronImg" id="macaronImg" alt="マカロン" />
            <img class="newborn" id="newbornImg" alt="生まれかけ" />
          </div>

          <!-- 誕生後（2人） -->
          <div class="petRow" id="petRow" style="display:none;">
            <div class="petSlot" id="petA">
              <img class="petImg" id="petImgA" alt="あなた" />
            </div>
            <div class="petSlot" id="petB">
              <img class="petImg" id="petImgB" alt="生まれた子" />
            </div>
          </div>
        </div>

        <div class="cardBody">
          <div class="actions" id="actions">
            <button class="btn" id="actFood"><span>食事</span><span class="muted">2択</span></button>
            <button class="btn" id="actOut"><span>お出かけ</span><span class="muted">2択</span></button>
            <button class="btn" id="actMini"><span>ミニゲーム</span><span class="muted">2択</span></button>
            <button class="btn" id="actClean"><span>おそうじ</span><span class="muted">2択</span></button>
          </div>

          <div style="display:flex; gap:10px; margin-top: 12px; flex-wrap:wrap;">
            <button class="btn small dark" id="useDrink">ドリンク</button>
            <button class="btn small dark" id="useMacaron">マカロン</button>
            <div class="pill" title="明示的な寿命カウントダウンは表示しません">
              <span class="muted">時間は内側で進みます</span>
            </div>
          </div>

          <div class="muted" style="margin-top:10px; font-size:12px;">
            正解や評価は出しません。選んだことだけが残ります。
          </div>
        </div>
      </div>

      <div class="card">
        <div class="cardHead">
          <div>
            <div style="font-weight:650;">ログ</div>
            <div class="sub">日ごとの事実 / 周回の履歴</div>
          </div>
          <div class="btnRow">
            <button class="btn small" id="btnShowLog">表示更新</button>
          </div>
        </div>
        <div class="cardBody">
          <div class="logBox" id="logBox"></div>
        </div>
      </div>
    </div>
  </div>

<script>
/* =========================
   画像パス（public/ から始める）
   あなたの環境に合わせて、必要ならここだけ増やす
   ========================= */
const ASSETS = {
  baby: {
    blue:   ["public/stag1/baby_blue.png",   "public/stage1/baby_blue.png",   "public/char/baby_blue.png"],
    pink:   ["public/stag1/baby_pink.png",   "public/stage1/baby_pink.png",   "public/char/baby_pink.png"],
    green:  ["public/stag1/baby_green.png",  "public/stage1/baby_green.png",  "public/char/baby_green.png"],
    purple: ["public/stag1/baby_purple.png", "public/stage1/baby_purple.png", "public/char/baby_purple.png"],
  },
  buddy: { /* もし「自分側」の専用画像があるならここへ。無ければ baby を使う */
    blue:   ["public/stag1/buddy_blue.png"],
    pink:   ["public/stag1/buddy_pink.png"],
    green:  ["public/stag1/buddy_green.png"],
    purple: ["public/stag1/buddy_purple.png"],
  },
  macaron: {
    blue:   ["public/stag1/macaron_blue.png",   "public/stage1/macaron_blue.png",   "public/items/macaron_blue.png"],
    pink:   ["public/stag1/macaron_pink.png",   "public/stage1/macaron_pink.png",   "public/items/macaron_pink.png"],
    green:  ["public/stag1/macaron_green.png",  "public/stage1/macaron_green.png",  "public/items/macaron_green.png"],
    purple: ["public/stag1/macaron_purple.png", "public/stage1/macaron_purple.png", "public/items/macaron_purple.png"],
  }
};

const CFG = {
  hatchMs: 3 * 60 * 1000,                 // マカロン→誕生：3分
  lifeMs:  3 * 24 * 60 * 60 * 1000,       // 寿命：3日
  reviveMs: 20 * 60 * 1000,               // マカロン（死後）一時復活
  drinkExtendMs: 2 * 60 * 60 * 1000,      // ドリンク延命
  tickMs: 1000,
  hungerRatePerHour: 12,
  wasteRatePerHour:  10,
};

const LS_KEY = "care3days_macaron_v1";

/* DOM */
const $ = (id)=>document.getElementById(id);
const heartRow = $("heartRow");
const logBox = $("logBox");
const modeLabel = $("modeLabel");

const sitterDot = $("sitterDot");
const sitterText = $("sitterText");

const macaronWrap = $("macaronWrap");
const macaronImg  = $("macaronImg");
const newbornImg  = $("newbornImg");

const petRow  = $("petRow");
const petA    = $("petA");
const petB    = $("petB");
const petImgA = $("petImgA");
const petImgB = $("petImgB");

const homeGate = $("homeGate");
const homeTitle = $("homeTitle");
const homeText  = $("homeText");
const homeTiny  = $("homeTiny");
const colorPicks = $("colorPicks");
const btnContinue = $("btnContinue");
const btnStart = $("btnStart");

const thanks = $("thanks");
const btnRestartLog  = $("btnRestartLog");
const btnRestartKeep = $("btnRestartKeep");
const btnEndToHome   = $("btnEndToHome");

/* URLモード（観察用） */
const url = new URL(location.href);
const isObserve = url.searchParams.has("observe");

/* 状態 */
let state = loadState();
if (!state) state = freshState();

/* 観察モードUI */
if (isObserve) {
  modeLabel.textContent = "観察用ログ（操作できません）";
  $("actions").style.display = "none";
  $("btnSitter").style.display = "none";
  $("btnReset").style.display = "none";
  $("useDrink").style.display = "none";
  $("useMacaron").style.display = "none";
  $("btnShare").style.display = "none";
  $("btnHome").style.display = "none";
  $("subHint").textContent = "操作はできません";
  $("btnShowLog").textContent = "ログを表示";
}

/* 観察用URLならhashデータ読み込み */
if (isObserve) {
  const imported = tryImportFromHash();
  if (imported) state = imported;
}

/* ホームUI初期化 */
buildColorPicks();
syncHomeTexts();

/* イベント */
$("btnShowLog").addEventListener("click", ()=>renderLog());
$("btnShare").addEventListener("click", ()=>openShare());
$("btnReset").addEventListener("click", ()=>{
  if (!confirm("本当に全部消しますか？履歴も消えます。")) return;
  localStorage.removeItem(LS_KEY);
  location.reload();
});
$("btnSitter").addEventListener("click", ()=>{ if(!isObserve) toggleSitter(); });
$("btnHome").addEventListener("click", ()=>{ if(!isObserve) openHome(); });

btnContinue.addEventListener("click", ()=>{
  if (isObserve) return;
  closeHome();
  renderAll();
});

btnStart.addEventListener("click", ()=>{
  if (isObserve) return;
  startNewRun({ keepAppearance: false, keepLogs: true });
});

btnRestartLog.addEventListener("click", ()=>{
  if (isObserve) return;
  startNewRun({ keepAppearance: false, keepLogs: true });
});
btnRestartKeep.addEventListener("click", ()=>{
  if (isObserve) return;
  startNewRun({ keepAppearance: true, keepLogs: true });
});
btnEndToHome.addEventListener("click", ()=>{
  if (isObserve) return;
  openHome(true);
});

/* お世話 */
$("actFood").addEventListener("click", ()=>openTwoChoice("食事", [
  {label:"軽い食事",  key:"food_light"},
  {label:"しっかり食事", key:"food_heavy"},
], (choiceKey)=>applyCare("food", choiceKey)));

$("actOut").addEventListener("click", ()=>openTwoChoice("お出かけ", [
  {label:"外に出る", key:"out_go"},
  {label:"家で過ごす", key:"out_home"},
], (choiceKey)=>applyCare("outing", choiceKey)));

$("actMini").addEventListener("click", ()=>openTwoChoice("ミニゲーム", [
  {label:"左の箱を選ぶ", key:"mini_left"},
  {label:"右の箱を選ぶ", key:"mini_right"},
], (choiceKey)=>applyCare("mini", choiceKey)));

$("actClean").addEventListener("click", ()=>openTwoChoice("おそうじ", [
  {label:"今すぐやる", key:"clean_now"},
  {label:"あとで", key:"clean_later"},
], (choiceKey)=>{
  if (choiceKey === "clean_now") openCleanGame();
  else { applyCare("clean", choiceKey); }
}));

$("useDrink").addEventListener("click", ()=>{
  if (isObserve) return;
  if (!isAliveVirtual()) return;
  applyItem("drink");
});
$("useMacaron").addEventListener("click", ()=>{
  if (isObserve) return;
  if (isAliveVirtual()) return;
  applyItem("macaron");
});

/* 起動時：必ずホームを出す（ここが「最初のページが消えた」対策） */
openHome();

/* ループ */
renderAll();
renderLog();
setInterval(()=>tick(), CFG.tickMs);

/* =========================
   画像フォールバック
   ========================= */
function setImageWithFallback(imgEl, candidates){
  if(!imgEl) return;
  let idx = 0;

  // placeholder削除
  const oldPh = imgEl.parentElement.querySelector(".imgPlaceholder");
  if (oldPh) oldPh.remove();

  imgEl.style.display = "";
  imgEl.onerror = () => {
    idx++;
    if (idx < candidates.length) {
      imgEl.src = candidates[idx];
      return;
    }
    imgEl.style.display = "none";
    addPlaceholder(imgEl.parentElement);
  };
  imgEl.src = candidates[idx];
}

function addPlaceholder(parent){
  if (parent.querySelector(".imgPlaceholder")) return;
  const ph = document.createElement("div");
  ph.className = "imgPlaceholder";
  ph.textContent = "画像を差し替えてください";
  parent.appendChild(ph);
}

/* =========================
   色ルール（バラエティ）
   青→ピンク固定
   緑→ピンク or 紫
   ピンク→青固定
   紫→ピンク or 緑
   ========================= */
function derivePetColor(playerColor){
  if (playerColor === "blue") return "pink";
  if (playerColor === "green") return (Math.random() < 0.5) ? "pink" : "purple";
  if (playerColor === "pink") return "blue";
  if (playerColor === "purple") return (Math.random() < 0.5) ? "pink" : "green";
  return "pink";
}

/* =========================
   ホーム
   ========================= */
function buildColorPicks(){
  const colors = [
    {k:"blue",   label:"Blue",   c:"#60a5fa"},
    {k:"green",  label:"Green",  c:"#34d399"},
    {k:"pink",   label:"Pink",   c:"#fb7185"},
    {k:"purple", label:"Purple", c:"#a78bfa"},
  ];
  colorPicks.innerHTML = "";
  colors.forEach(it=>{
    const b = document.createElement("button");
    b.className = "pick" + (state.colors.player === it.k ? " on" : "");
    b.type = "button";
    b.innerHTML = `<span class="swatch" style="background:${it.c}"></span><span>${it.label}</span>`;
    b.addEventListener("click", ()=>{
      state.colors.player = it.k;
      saveState();
      buildColorPicks();
      syncHomeTexts();
      // ここで “次に出てくる子” を決める（開始前に確定）
      state.colors.pet = derivePetColor(state.colors.player);
      state.colors.macaron = state.colors.pet;
      saveState();
    });
    colorPicks.appendChild(b);
  });
}

function syncHomeTexts(){
  const hasRun = state.run.started && !state.run.ended;
  const ended = state.run.ended;

  if (ended) {
    homeTitle.textContent = "はじめに戻る";
    homeText.innerHTML = "前の周回は終わりました。<br>次の周回を選べます。";
    homeTiny.textContent = "「ログを残す」は履歴に残して新しい周回へ。「姿を引き継ぐ」は色（見た目）を引き継いで新しい周回へ。";
  } else if (hasRun) {
    homeTitle.textContent = "続きから / 最初から";
    homeText.innerHTML = "前の続きが残っています。<br>続きから遊ぶか、最初から始められます。";
    homeTiny.textContent = "画像が出ない時は、public/stag1/ のファイル名を確認してください。";
  } else {
    homeTitle.textContent = "はじめる";
    homeText.innerHTML = "しばらくすると、マカロンが薄くなり、生まれます。<br>正解や評価はありません。";
    homeTiny.textContent = "青ならピンク、緑ならピンク/紫など、色の組み合わせは少し揺れます。";
  }

  btnContinue.style.display = (hasRun && !ended) ? "" : "none";
  btnStart.textContent = ended ? "最初から（新しい周回）" : "最初から";
}

function openHome(fromEnd=false){
  // 終了時は thanks を隠してホームへ
  if (fromEnd) {
    thanks.classList.remove("show");
  }
  homeGate.classList.add("show");
  syncHomeTexts();
  renderTop();
  renderLog();
}

function closeHome(){
  homeGate.classList.remove("show");
}

/* =========================
   新しい周回
   keepLogs: true なら履歴に残す
   keepAppearance: true なら色を引き継ぐ
   ========================= */
function startNewRun({ keepLogs=true, keepAppearance=false }){
  // 前周回を履歴に残す
  if (keepLogs && state.run.started) {
    const snapshot = {
      endedAt: Date.now(),
      colors: {...state.colors},
      log: state.log.current,
      heartsEnd: state.hearts,
    };
    state.log.history.unshift(snapshot);
    if (state.log.history.length > 30) state.log.history.pop();
  }

  // 色を決める
  if (!keepAppearance) {
    // すでにホームで playerColor を選んでいる想定
    if (!state.colors.player) state.colors.player = "blue";
    state.colors.pet = derivePetColor(state.colors.player);
    state.colors.macaron = state.colors.pet;
  } else {
    // 引き継ぐ（player/pet/macaron そのまま）
    if (!state.colors.player) state.colors.player = "blue";
    if (!state.colors.pet) state.colors.pet = derivePetColor(state.colors.player);
    if (!state.colors.macaron) state.colors.macaron = state.colors.pet;
  }

  // 進行情報を初期化
  const vNow = virtualNowRawReset(); // pausedTotalMs を前提にしない初期化
  state.run = { started:true, ended:false, hatched:false };
  state.flags = { weirdRevive:false };
  state.needs = { hunger: 0.15, waste: 0.12 };
  state.mood = "good";
  state.hearts = 3;
  state.items = { drinkUsed: 0, macaronUsed: 0 };

  state.sitter = { on:false, pausedTotalMs:0, startedRealMs:null, frozenVirtualMs:null };

  state.time = {
    arrivalVirtualMs: vNow,
    hatchVirtualMs: vNow + CFG.hatchMs,
    deathVirtualMs: vNow + CFG.lifeMs,
    reviveUntilVirtualMs: null,
    lastTickVirtualMs: vNow,
  };

  state.log.current = freshDayLog();
  closeHome();

  // 誕生前表示の準備
  preparePreHatchVisual();

  saveState();
  renderAll();
  renderLog();
}

function virtualNowRawReset(){
  return Date.now();
}

function freshDayLog(){
  return {
    days: {1: blankDay(), 2: blankDay(), 3: blankDay()},
    startedAt: isoNow(),
    sitterTotalMs: 0
  };
}

function blankDay(){
  return {
    actions: { food:0, outing:0, mini:0, clean:0, drink:0, macaron:0 },
    choices: [],
    heartDelta: 0,
    sitterMs: 0,
    sitterEvents: [],
  };
}

/* =========================
   時間（シッター停止）
   ========================= */
function realNow(){ return Date.now(); }
function virtualNow(){
  if (state.sitter.on) return state.sitter.frozenVirtualMs;
  return realNow() - state.sitter.pausedTotalMs;
}
function virtualNowRaw(){
  return realNow() - (state.sitter?.pausedTotalMs || 0);
}

function toggleSitter(){
  if (!state.run.started || state.run.ended) return;

  if (!state.sitter.on) {
    state.sitter.on = true;
    state.sitter.startedRealMs = realNow();
    state.sitter.frozenVirtualMs = virtualNow();
    logSitter("on", 0);
  } else {
    const used = realNow() - state.sitter.startedRealMs;
    state.sitter.pausedTotalMs += used;
    state.sitter.on = false;
    state.sitter.startedRealMs = null;
    logSitter("off", used);
    state.log.current.sitterTotalMs += used;
  }
  saveState();
  renderTop();
  renderLog();
}

function logSitter(type, ms){
  const d = dayIndex();
  ensureDay(d);
  const day = state.log.current.days[d];
  day.sitterEvents.push({type, at: isoNow(), ms});
  if (type === "off") day.sitterMs += ms;
}

/* =========================
   生死判定
   ========================= */
function arrivalMs(){ return state.time.arrivalVirtualMs; }
function hatchMs(){ return state.time.hatchVirtualMs; }
function deathMs(){ return state.time.deathVirtualMs; }

function isHatchedVirtual(){
  if (!state.run.started) return false;
  return virtualNow() >= hatchMs();
}
function isAliveVirtual(){
  if (!state.run.started) return false;
  const v = virtualNow();
  const aliveByLife = v < deathMs();
  const revived = (state.time.reviveUntilVirtualMs && v < state.time.reviveUntilVirtualMs);
  return aliveByLife || revived;
}
function dayIndex(){
  if (!state.run.started) return 1;
  const v = virtualNow();
  const d = Math.floor((v - arrivalMs()) / (24*60*60*1000)) + 1;
  return Math.max(1, Math.min(3, d));
}

/* =========================
   tick
   ========================= */
function tick(){
  if (!state.run.started) return;

  if (state.run.ended) {
    renderTop();
    return;
  }

  // 死（復活してない）→ありがとう表示（ここが「ありがとうの後、はじめに戻る」の入口）
  if (!isAliveVirtual()) {
    state.run.ended = true;
    saveState();
    renderAll();
    renderLog();
    showThanks();
    return;
  }

  const v = virtualNow();
  const dt = Math.max(0, v - state.time.lastTickVirtualMs);
  state.time.lastTickVirtualMs = v;

  // 誕生前：演出だけ
  if (!isHatchedVirtual()) {
    const remain = hatchMs() - v;
    // 15秒前から“薄くなる気配”を強める（見た目だけ）
    if (remain <= 15000) macaronWrap.classList.add("fading");
    saveState();
    renderAll();
    return;
  }

  // 誕生した瞬間（演出を一回だけ）
  if (!state.run.hatched) {
    state.run.hatched = true;
    playHatchAnimation();
    saveState();
  }

  // 生存中：needsが進む
  const hour = dt / (60*60*1000);
  state.needs.hunger = clamp01(state.needs.hunger + (CFG.hungerRatePerHour/100) * hour);
  state.needs.waste  = clamp01(state.needs.waste  + (CFG.wasteRatePerHour/100)  * hour);

  const bad = Math.max(state.needs.hunger, state.needs.waste);
  state.mood = (bad < 0.45) ? "good" : (bad < 0.75 ? "low" : "cry");

  saveState();
  renderAll();
}

function showThanks(){
  thanks.classList.add("show");
}

/* =========================
   見た目の準備
   ========================= */
function preparePreHatchVisual(){
  const macColor = state.colors.macaron || "pink";
  const petColor = state.colors.pet || "pink";

  setImageWithFallback(macaronImg, ASSETS.macaron[macColor] || ASSETS.macaron.pink);

  // “生まれかけ”は pet の画像を小さく出す
  setImageWithFallback(newbornImg, pickBabyCandidates(petColor));
  newbornImg.classList.remove("newbornReveal");
  macaronImg.classList.remove("macaronFade");

  // 誕生後の2人
  setImageWithFallback(petImgA, pickBuddyCandidates(state.colors.player || "blue"));
  setImageWithFallback(petImgB, pickBabyCandidates(petColor));
}

function pickBabyCandidates(color){
  const list = (ASSETS.baby[color] || ASSETS.baby.pink).slice();
  // 念のため blue 指定のパスも混ぜる（ユーザー指定を最優先にしたい）
  if (color === "blue") {
    if (!list.includes("public/stag1/baby_blue.png")) list.unshift("public/stag1/baby_blue.png");
  }
  return list;
}
function pickBuddyCandidates(color){
  const buddy = ASSETS.buddy[color] || [];
  const baby  = ASSETS.baby[color] || ASSETS.baby.pink;
  return buddy.concat(baby);
}

/* 誕生アニメ */
function playHatchAnimation(){
  // マカロンを消しつつ、newborn を一瞬出す
  newbornImg.style.opacity = "0";
  macaronImg.classList.add("macaronFade");
  newbornImg.classList.add("newbornReveal");
}

/* =========================
   お世話とアイテム
   ========================= */
function applyCare(type, choiceKey){
  if (!state.run.started || state.run.ended) return;
  if (!isHatchedVirtual()) return;
  if (!isAliveVirtual()) return;
  if (state.sitter.on) return;

  const d = dayIndex();
  ensureDay(d);

  let heartDelta = 0;

  if (type === "food") {
    state.needs.hunger = clamp01(state.needs.hunger - (choiceKey === "food_heavy" ? 0.38 : 0.22));
    heartDelta = (choiceKey === "food_heavy") ? +2 : +1;
  }
  if (type === "outing") {
    state.needs.hunger = clamp01(state.needs.hunger + 0.06);
    state.needs.waste  = clamp01(state.needs.waste  + 0.05);
    heartDelta = (choiceKey === "out_go") ? +2 : +1;
  }
  if (type === "mini") {
    heartDelta = (Math.random() < 0.5) ? +1 : +2;
    state.needs.hunger = clamp01(state.needs.hunger + 0.03);
  }
  if (type === "clean") {
    heartDelta = 0;
    state.needs.waste = clamp01(state.needs.waste + 0.08);
  }

  state.hearts = clampInt(state.hearts + heartDelta, 0, 10);

  const day = state.log.current.days[d];
  day.actions[type] = (day.actions[type] || 0) + 1;
  day.choices.push({at: isoNow(), type, choice: choiceKey});
  day.heartDelta += heartDelta;

  saveState();
  renderAll();
  renderLog();
}

function applyItem(item){
  const d = dayIndex();
  ensureDay(d);

  if (item === "drink") {
    if (state.items.drinkUsed >= 3) return;
    state.items.drinkUsed += 1;

    state.time.deathVirtualMs += CFG.drinkExtendMs;
    state.needs.hunger = clamp01(state.needs.hunger - 0.18);
    state.needs.waste  = clamp01(state.needs.waste  - 0.12);
    state.hearts = clampInt(state.hearts + 1, 0, 10);

    const day = state.log.current.days[d];
    day.actions.drink = (day.actions.drink || 0) + 1;
    day.choices.push({at: isoNow(), type:"drink", choice:"use"});
    day.heartDelta += 1;
  }

  if (item === "macaron") {
    if (state.items.macaronUsed >= 2) return;
    if (isAliveVirtual()) return;

    state.items.macaronUsed += 1;
    state.time.reviveUntilVirtualMs = virtualNow() + CFG.reviveMs;
    state.flags.weirdRevive = true;

    state.needs.hunger = clamp01(Math.max(state.needs.hunger, 0.55));
    state.needs.waste  = clamp01(Math.max(state.needs.waste,  0.45));

    const day = state.log.current.days[d];
    day.actions.macaron = (day.actions.macaron || 0) + 1;
    day.choices.push({at: isoNow(), type:"macaron", choice:"use"});
  }

  saveState();
  renderAll();
  renderLog();
}

/* おそうじミニゲーム */
function openCleanGame(){
  // 簡易：即改善（短時間で終わる前提）
  applyCare("clean", "clean_game");
  state.needs.waste = clamp01(state.needs.waste - 0.42);
  state.hearts = clampInt(state.hearts + 1, 0, 10);

  const d = dayIndex();
  ensureDay(d);
  const day = state.log.current.days[d];
  day.actions.clean = (day.actions.clean || 0) + 1;
  day.choices.push({at: isoNow(), type:"clean", choice:"clean_game"});
  day.heartDelta += 1;

  saveState();
  renderAll();
  renderLog();
}

/* =========================
   2択（超シンプル：confirmで完結）
   ========================= */
function openTwoChoice(title, options, onPick){
  if (isObserve) return;
  if (!state.run.started || state.run.ended) return;
  if (!isHatchedVirtual()) return;
  if (!isAliveVirtual()) return;
  if (state.sitter.on) return;

  const a = options[0], b = options[1];
  const ok = confirm(title + "\n\n" + a.label + " → OK\n" + b.label + " → キャンセル");
  onPick(ok ? a.key : b.key);
}

/* =========================
   描画
   ========================= */
function renderAll(){
  renderStage();
  renderTop();
}

function renderTop(){
  // ハート
  heartRow.innerHTML = "";
  const n = clampInt(state.hearts, 0, 10);
  for (let i=0;i<10;i++){
    const d = document.createElement("div");
    d.className = "h" + (i < n ? " on" : "");
    heartRow.appendChild(d);
  }

  // シッター
  if (state.sitter.on) {
    sitterDot.classList.add("pause");
    sitterText.textContent = "停止中";
  } else {
    sitterDot.classList.remove("pause");
    sitterText.textContent = "進行中";
  }
}

function renderStage(){
  // 終了
  thanks.classList.toggle("show", !!state.run.ended);

  // 開始前は何も出さない（ホームが上に出ている）
  if (!state.run.started) {
    macaronWrap.style.display = "none";
    petRow.style.display = "none";
    setMoodClass(null);
    setWeird(false);
    return;
  }

  // 誕生前：マカロン
  if (!isHatchedVirtual()) {
    macaronWrap.style.display = "";
    petRow.style.display = "none";
    preparePreHatchVisual();
    setMoodClass(null);
    setWeird(false);
    return;
  }

  // 誕生後：2人
  macaronWrap.style.display = "none";
  petRow.style.display = "";
  setMoodClass(state.mood);

  // 少しずつ大きくなる
  const pct = lifeProgress01();
  const base = cssFloat("--grow-min", .52);
  const max  = cssFloat("--grow-max", .96);
  const s = base + (max-base)*pct;
  petImgB.style.transform = `scale(${s})`;
  petImgA.style.transform = `scale(1.02)`; // あなた側はほぼ固定

  setWeird(!!state.flags.weirdRevive && !state.run.ended);

  // 画像
  setImageWithFallback(petImgA, pickBuddyCandidates(state.colors.player || "blue"));
  setImageWithFallback(petImgB, pickBabyCandidates(state.colors.pet || "pink"));
}

function lifeProgress01(){
  const v = virtualNow();
  const total = (deathMs() - arrivalMs());
  if (total <= 0) return 0;
  return clamp01((v - arrivalMs()) / total);
}
function cssFloat(varName, fallback){
  const v = parseFloat(getComputedStyle(document.documentElement).getPropertyValue(varName));
  return Number.isFinite(v) ? v : fallback;
}

function setMoodClass(mood){
  const moods = ["mood-good","mood-low","mood-cry"];
  [petA, petB].forEach(el=>{
    moods.forEach(c=>el.classList.remove(c));
    if (mood === "good") el.classList.add("mood-good");
    if (mood === "low")  el.classList.add("mood-low");
    if (mood === "cry")  el.classList.add("mood-cry");
  });
}
function setWeird(on){
  [petA, petB].forEach(el=> el.classList.toggle("weird", on));
}

/* =========================
   ログ
   ========================= */
function renderLog(){
  const lines = [];
  lines.push(`ID: ${state.playerId}`);
  lines.push(`周回: ${state.log.history.length + (state.run.started ? 1 : 0)}（履歴 ${state.log.history.length}）`);
  lines.push("");

  if (!state.run.started){
    lines.push("まだ開始していません。");
  } else {
    const trend = computeHeartTrend(state.log.current);
    lines.push("現在の周回");
    lines.push(`  Day1: ${trend[1].from} → ${trend[1].to}`);
    lines.push(`  Day2: ${trend[2].from} → ${trend[2].to}`);
    lines.push(`  Day3: ${trend[3].from} → ${trend[3].to}`);
    lines.push("");

    for (let d=1; d<=3; d++){
      ensureDay(d);
      const day = state.log.current.days[d];
      lines.push(`Day ${d}`);
      lines.push(`  お世話回数`);
      lines.push(`    食事: ${day.actions.food || 0}`);
      lines.push(`    お出かけ: ${day.actions.outing || 0}`);
      lines.push(`    ミニゲーム: ${day.actions.mini || 0}`);
      lines.push(`    おそうじ: ${day.actions.clean || 0}`);
      lines.push(`  アイテム`);
      lines.push(`    ドリンク: ${day.actions.drink || 0}`);
      lines.push(`    マカロン: ${day.actions.macaron || 0}`);
      lines.push(`  ハート変化: ${signed(day.heartDelta || 0)}`);
      lines.push(`  シッター: ${msToShort(day.sitterMs || 0)}`);
      lines.push(`  選択`);
      if (!day.choices.length){
        lines.push(`    （なし）`);
      } else {
        day.choices.slice(-12).forEach(c=>{
          lines.push(`    - ${c.at} / ${c.type} / ${c.choice}`);
        });
        if (day.choices.length > 12) lines.push(`    …（省略）`);
      }
      lines.push("");
    }
    lines.push(`累計`);
    lines.push(`  ドリンク使用: ${state.items.drinkUsed}/3`);
    lines.push(`  マカロン使用: ${state.items.macaronUsed}/2`);
    lines.push("");
  }

  if (state.log.history.length){
    lines.push("履歴（古い周回ほど下）");
    state.log.history.slice(0, 8).forEach((h, i)=>{
      const c = h.colors || {};
      lines.push(`  #${i+1} colors: player=${c.player||"-"} / pet=${c.pet||"-"} / macaron=${c.macaron||"-"}  heartsEnd=${h.heartsEnd ?? "-"}`);
    });
  }

  logBox.textContent = lines.join("\n");
}

function computeHeartTrend(log){
  const res = {1:{from:3,to:3},2:{from:3,to:3},3:{from:3,to:3}};
  const base = 3;
  const d1 = (log.days[1].heartDelta || 0);
  const d2 = (log.days[2].heartDelta || 0);
  const d3 = (log.days[3].heartDelta || 0);
  res[1].from = base; res[1].to = clampInt(base + d1, 0, 10);
  res[2].from = res[1].to; res[2].to = clampInt(res[2].from + d2, 0, 10);
  res[3].from = res[2].to; res[3].to = clampInt(res[3].from + d3, 0, 10);
  return res;
}

/* =========================
   共有（観察用）
   ========================= */
function openShare(){
  const shareUrl = buildShareURL();
  prompt("このURLを共有すると、観察用ログだけ見られます（操作不可）", shareUrl);
}

function buildShareURL(){
  const payload = {
    v: 1,
    playerId: state.playerId,
    colors: state.colors,
    hearts: state.hearts,
    log: state.log,
    run: state.run,
  };
  const packed = btoa(unescape(encodeURIComponent(JSON.stringify(payload))));
  const base = location.origin + location.pathname;
  return `${base}?observe=${encodeURIComponent(state.playerId)}#data=${encodeURIComponent(packed)}`;
}

function tryImportFromHash(){
  const h = location.hash || "";
  const m = h.match(/data=([^&]+)/);
  if (!m) return null;
  try{
    const json = decodeURIComponent(escape(atob(decodeURIComponent(m[1]))));
    const payload = JSON.parse(json);
    if (!payload || payload.v !== 1) return null;

    const s = freshState();
    s.playerId = payload.playerId || (url.searchParams.get("observe") || s.playerId);
    s.colors = payload.colors || s.colors;
    s.hearts = payload.hearts ?? s.hearts;
    s.log = payload.log || s.log;
    s.run = payload.run || s.run;

    // 観察用：進行停止
    s.sitter = {on:true, frozenVirtualMs: Date.now(), pausedTotalMs: 0, startedRealMs: null};
    s.run.ended = true;
    return s;
  }catch(e){
    return null;
  }
}

/* =========================
   保存・読み込み
   ========================= */
function loadState(){
  const raw = localStorage.getItem(LS_KEY);
  if (!raw) return null;
  try{ return JSON.parse(raw); }catch(e){ return null; }
}
function saveState(){
  localStorage.setItem(LS_KEY, JSON.stringify(state));
}
function freshState(){
  return {
    playerId: makeId(),
    colors: { player:"blue", pet:"pink", macaron:"pink" },
    run: { started:false, ended:false, hatched:false },
    flags: { weirdRevive:false },
    time: { arrivalVirtualMs: 0, hatchVirtualMs: 0, deathVirtualMs: 0, reviveUntilVirtualMs: null, lastTickVirtualMs: 0 },
    sitter: { on:false, pausedTotalMs:0, startedRealMs:null, frozenVirtualMs:null },
    needs: { hunger: 0.15, waste: 0.12 },
    mood: "good",
    hearts: 3,
    items: { drinkUsed: 0, macaronUsed: 0 },
    log: { current: freshDayLog(), history: [] }
  };
}

function ensureDay(d){
  if (!state.log.current.days[d]) state.log.current.days[d] = blankDay();
}

/* =========================
   便利
   ========================= */
function clamp01(x){ return Math.max(0, Math.min(1, x)); }
function clampInt(x, a, b){ x = Math.round(x); return Math.max(a, Math.min(b, x)); }
function isoNow(){
  const dt = new Date();
  const y = dt.getFullYear();
  const m = String(dt.getMonth()+1).padStart(2,"0");
  const d = String(dt.getDate()).padStart(2,"0");
  const hh = String(dt.getHours()).padStart(2,"0");
  const mm = String(dt.getMinutes()).padStart(2,"0");
  const ss = String(dt.getSeconds()).padStart(2,"0");
  return `${y}-${m}-${d} ${hh}:${mm}:${ss}`;
}
function signed(n){ return (n>0?`+${n}`:`${n}`); }
function msToShort(ms){
  const s = Math.floor(ms/1000);
  const h = Math.floor(s/3600);
  const m = Math.floor((s%3600)/60);
  if (h<=0 && m<=0) return "0m";
  if (h<=0) return `${m}m`;
  return `${h}h ${m}m`;
}
function makeId(){
  return "p" + Math.random().toString(36).slice(2,8) + "-" + Math.random().toString(36).slice(2,6);
}

/* 初回：色ルールを確定して保存 */
state.colors.pet = derivePetColor(state.colors.player);
state.colors.macaron = state.colors.pet;
saveState();
preparePreHatchVisual();
renderAll();
renderLog();
</script>
</body>
</html>
