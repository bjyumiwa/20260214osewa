<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>3日間のお世話ゲーム（プロトタイプ）</title>
  <style>
    :root{
      --bg:#eef8ff;
      --card:rgba(255,255,255,.78);
      --card2:rgba(255,255,255,.62);
      --text:#0f172a;
      --muted:#475569;
      --line:rgba(15,23,42,.12);

      --btn:#2dd4bf;
      --btnText:#042f2e;

      --btn2:#60a5fa;
      --danger:#fb7185;
      --ok:#34d399;

      --shadow: 0 16px 38px rgba(15,23,42,.12);
      --radius: 18px;
    }
    *{ box-sizing:border-box; }
    body{
      margin:0;
      font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Yu Gothic", "Meiryo", sans-serif;
      color:var(--text);
      background:
        radial-gradient(1200px 700px at 15% 0%, rgba(45,212,191,.26), transparent 55%),
        radial-gradient(900px 600px at 85% 10%, rgba(96,165,250,.22), transparent 55%),
        radial-gradient(900px 900px at 45% 110%, rgba(167,243,208,.30), transparent 55%),
        linear-gradient(180deg, #f6fdff, #eef8ff 35%, #f7fbff);
      min-height:100vh;
      overflow-x:hidden;
    }
    .wrap{ max-width:980px; margin:0 auto; padding:18px; }

    .topbar{
      display:flex; align-items:center; justify-content:space-between;
      gap:10px;
      flex-wrap:wrap;
      padding:12px 14px;
      background: var(--card2);
      border:1px solid var(--line);
      border-radius: 16px;
      box-shadow: var(--shadow);
      backdrop-filter: blur(10px);
    }
    .navlinks{
      display:flex;
      gap:8px;
      flex-wrap:wrap;
      align-items:center;
      justify-content:center;
    }
    .navbtn{
      appearance:none;
      border:1px solid var(--line);
      background: rgba(255,255,255,.55);
      color: var(--text);
      border-radius: 999px;
      padding:8px 12px;
      font-size: 13px;
      cursor:pointer;
      box-shadow: 0 10px 18px rgba(15,23,42,.08);
      transition: transform .08s ease, filter .12s ease;
      white-space:nowrap;
    }
    .navbtn:hover{ transform: translateY(-1px); filter:saturate(1.05); }
    .navbtn:active{ transform: translateY(0px) scale(.99); }
    .brand{ display:flex; gap:10px; align-items:center; }
    .dot{
      width:12px; height:12px; border-radius:999px;
      background: linear-gradient(135deg, rgba(45,212,191,.95), rgba(96,165,250,.90));
      box-shadow: 0 0 18px rgba(45,212,191,.28);
    }
    .title{ font-weight:800; letter-spacing:.02em; font-size:14px; color:rgba(15,23,42,.92); }
    .sub{ font-size:12px; color:var(--muted); margin-top:2px; }

    .pill{
      display:flex; align-items:center; gap:8px;
      padding:8px 10px;
      border-radius:999px;
      background: rgba(255,255,255,.55);
      border:1px solid var(--line);
      font-size:12px;
      color: rgba(15,23,42,.85);
      user-select:none;
    }
    .pill small{ color:var(--muted); }

    .grid{
      display:grid;
      gap:14px;
      grid-template-columns: 1.2fr .8fr;
      margin-top:14px;
    }
    @media (max-width: 880px){
      .grid{ grid-template-columns: 1fr; }
    }

    .card{
      background: var(--card);
      border: 1px solid var(--line);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      overflow:hidden;
      position:relative;
    }
    .card .inner{ padding:14px; }
    .card h2{
      margin:0;
      font-size:14px;
      letter-spacing:.02em;
      color:rgba(15,23,42,.92);
      font-weight:800;
    }
    .card p{
      margin:10px 0 0 0;
      font-size:13px;
      line-height:1.75;
      color: rgba(15,23,42,.80);
    }
    .muted{ color:var(--muted); }

    .btnrow{ display:flex; gap:10px; flex-wrap:wrap; margin-top:12px; }
    button{
      border:0;
      background:none;
      color:inherit;
      font:inherit;
      cursor:pointer;
    }
    .btn{
      padding:10px 12px;
      border-radius:14px;
      background: linear-gradient(135deg, rgba(45,212,191,.95), rgba(45,212,191,.78));
      color: var(--btnText);
      font-weight:800;
      box-shadow: 0 12px 24px rgba(45,212,191,.14);
      border:1px solid rgba(15,23,42,.10);
      transition: transform .08s ease, filter .12s ease;
    }
    .btn:hover{ filter:brightness(1.03); }
    .btn:active{ transform: translateY(1px) scale(.99); }

    .btn.secondary{
      background: rgba(255,255,255,.55);
      color: rgba(15,23,42,.90);
      border:1px solid var(--line);
      box-shadow:none;
      font-weight:750;
    }
    .btn.blue{
      background: linear-gradient(135deg, rgba(96,165,250,.92), rgba(96,165,250,.72));
      color:#071223;
      box-shadow: 0 12px 24px rgba(96,165,250,.14);
    }
    .btn.danger{
      background: linear-gradient(135deg, rgba(251,113,133,.92), rgba(251,113,133,.72));
      color:#2a0b10;
      box-shadow: 0 12px 24px rgba(251,113,133,.14);
    }
    .btn:disabled{
      opacity:.50;
      cursor:not-allowed;
      filter:saturate(.7);
    }

    .screen{ display:none; }
    .screen.active{ display:block; }

    .stage{
      display:flex; align-items:center; justify-content:center;
      min-height: 420px;
      position:relative;
      padding:10px;
    }
    .charWrap{
      width: min(420px, 100%); height: 320px;
      display:grid; place-items:center;
      position:relative;
      user-select:none;
    }
    .charImg{
      width: 300px;
      height: 300px;
      object-fit:contain;
      filter: drop-shadow(0 20px 30px rgba(15,23,42,.18));
      transform-origin: 50% 80%;
    }
    /* ここから：誕生後は2人で並ぶ（小さく生まれ、3日かけて成長） */
    .charPair{
      position:absolute; inset:0;
      --growA: .50;
      --growB: .36;
      --sep: 96px;
      pointer-events:none;
    }
    .charTwin{
      position:absolute;
      bottom: 0;
      left: 50%;
      width: 280px;
      height: 280px;
      object-fit:contain;
      transform-origin: 50% 85%;
      filter: drop-shadow(0 20px 30px rgba(15,23,42,.18));
          transition: transform 650ms cubic-bezier(.2,.8,.2,1);
    }
    .charTwin.left{ transform: translateX(calc(-50% - var(--sep))) scale(var(--growA)) rotate(-3deg); }
    .charTwin.right{ transform: translateX(calc(-50% + var(--sep))) scale(var(--growB)) rotate(3deg); }

    /* 状態に合わせた動き（ラベルは出さない） */
    .charPair.k-happy{ animation: bop 1.2s ease-in-out infinite; }
    .charPair.k-ok{ animation: floaty 3.6s ease-in-out infinite; }
    .charPair.k-sad{ animation: droop 2.6s ease-in-out infinite; }
    .charPair.k-ended{ animation: droop 3.2s ease-in-out infinite; }
    .charPair.k-cry{ animation: crymix 1.0s ease-in-out infinite; }
    @keyframes crymix{
      0%,100%{ transform: translateY(8px) rotate(0deg); }
      25%{ transform: translateY(10px) rotate(-.8deg) translateX(-2px); }
      75%{ transform: translateY(10px) rotate(.8deg) translateX(2px); }
    }

    /* 復活の違和感：色味だけ少しズレる（動きは邪魔しない） */
    .charPair.uncanny .charTwin{
      filter:
        drop-shadow(0 20px 30px rgba(15,23,42,.18))
        hue-rotate(14deg)
        saturate(1.15)
        contrast(1.08);
    }

    /* 終了：灰色寄り */
    .charPair.k-ended .charTwin{
      filter: grayscale(.9) brightness(.88) drop-shadow(0 20px 30px rgba(15,23,42,.18));
    }
    /* ここまで：2人表示 */

    .floaty{ animation: floaty 3.6s ease-in-out infinite; }
    @keyframes floaty{
      0%,100%{ transform: translateY(0); }
      50%{ transform: translateY(-10px); }
    }
    .bop{ animation: bop 1.2s ease-in-out infinite; }
    @keyframes bop{
      0%,100%{ transform: translateY(0) scale(1); }
      50%{ transform: translateY(-8px) scale(1.01); }
    }
    .droop{ animation: droop 2.6s ease-in-out infinite; }
    @keyframes droop{
      0%,100%{ transform: translateY(0) rotate(0deg) scale(.995); filter: brightness(.98) contrast(1.02) drop-shadow(0 20px 30px rgba(15,23,42,.18)); }
      50%{ transform: translateY(10px) rotate(-1.5deg) scale(.985); filter: brightness(.86) contrast(1.02) drop-shadow(0 20px 30px rgba(15,23,42,.18)); }
    }
    .shake{ animation: shake .6s ease-in-out infinite; }
    @keyframes shake{
      0%,100%{ transform: translateX(0) rotate(0deg); }
      25%{ transform: translateX(-3px) rotate(-.8deg); }
      75%{ transform: translateX(3px) rotate(.8deg); }
    }
    .glitch{
      filter:
        drop-shadow(0 20px 30px rgba(15,23,42,.18))
        hue-rotate(14deg)
        saturate(1.15)
        contrast(1.08);
      animation: glitch 1.2s steps(2) infinite;
    }
    @keyframes glitch{
      0%,100%{ transform: translate(0,0) scale(1); }
      20%{ transform: translate(-1px, 1px) scale(1.001); }
      40%{ transform: translate(2px, -1px) scale(.999); }
      60%{ transform: translate(-2px, -1px) scale(1.002); }
      80%{ transform: translate(1px, 2px) scale(1); }
    }
    .tear{
      position:absolute;
      left:50%;
      top:74px;
      width: 22px; height: 22px;
      border-radius: 999px;
      background: radial-gradient(circle at 35% 35%, rgba(255,255,255,.95), rgba(96,165,250,.85) 35%, rgba(96,165,250,.18) 70%, transparent 75%);
      filter: blur(.1px);
      opacity:0;
      transform: translate(-110px, 18px) rotate(18deg);
      animation: tear 1.4s ease-in-out infinite;
      pointer-events:none;
    }
    @keyframes tear{
      0%{ opacity:0; transform: translate(-110px, 18px) rotate(18deg) scale(.8); }
      20%{ opacity:.9; }
      80%{ opacity:.05; transform: translate(-104px, 56px) rotate(18deg) scale(1); }
      100%{ opacity:0; transform: translate(-104px, 56px) rotate(18deg) scale(1); }
    }
    .tear.on{ opacity:1; }

    .poop{
      position:absolute;
      width: 20px; height: 16px;
      border-radius: 8px 8px 12px 12px;
      background: linear-gradient(180deg, rgba(15,23,42,.10), rgba(15,23,42,.28));
      border:1px solid rgba(15,23,42,.14);
      opacity:0;
      transform: translate(0,0) scale(.95);
      filter: blur(.1px);
      pointer-events:none;
    }
    .poop.on{ opacity:.70; }
    .poop#po1{ left:36px; top:230px; transform: rotate(-10deg); }
    .poop#po2{ right:42px; top:246px; transform: rotate(12deg); }
    .poop#po3{ left: 86px; top:268px; transform: rotate(6deg) scale(.9); }
    .poop#po4{ right: 96px; top:276px; transform: rotate(-8deg) scale(.92); }

    .hearts{
      display:flex; gap:6px; align-items:center;
      padding:8px 10px; border-radius:14px;
      background: rgba(255,255,255,.55);
      border:1px solid var(--line);
      width: fit-content;
    }
    .heart{
      width: 14px; height: 14px;
      transform: rotate(45deg);
      position:relative;
      opacity:.30;
      filter: drop-shadow(0 2px 6px rgba(251,113,133,.20));
    }
    .heart::before,.heart::after{
      content:"";
      position:absolute;
      width: 14px; height: 14px;
      border-radius: 50%;
      background: rgba(251,113,133,.85);
      left:0; top:0;
    }
    .heart::after{ left:-7px; }
    .heart.on{ opacity:1; }
    .heart.on::before,.heart.on::after{ background: rgba(251,113,133,.95); }

    .choiceGrid{
      display:grid;
      grid-template-columns: repeat(2, 1fr);
      gap:12px;
      margin-top:12px;
    }
    @media (max-width:520px){ .choiceGrid{ grid-template-columns:1fr; } }
    .choice{
      border:1px solid var(--line);
      border-radius: 18px;
      background: rgba(255,255,255,.55);
      padding:12px;
      display:flex;
      gap:12px;
      align-items:center;
      transition: transform .12s ease, background .2s ease;
    }
    .choice:hover{ transform: translateY(-1px); background: rgba(255,255,255,.72); }
    .choice.selected{ border-color: rgba(45,212,191,.55); background: rgba(45,212,191,.14); }
    .choice.selected .tiny{ opacity: .95; }
    .choice img{
      width:72px; height:72px; object-fit:contain;
      filter: drop-shadow(0 12px 16px rgba(15,23,42,.14));
    }
    .choice .ctext{ flex:1; }
    .choice .ctext .cname{ font-weight:900; font-size:13px; }
    .choice .ctext .cdesc{ font-size:12px; margin-top:4px; color: var(--muted); line-height:1.55; }

    .mapGrid{
      display:grid;
      grid-template-columns: repeat(4, 1fr);
      gap:10px;
      margin-top:12px;
    }
    .tile{
      height:84px;
      border-radius:16px;
      border:1px solid var(--line);
      background: rgba(255,255,255,.50);
      position:relative;
      overflow:hidden;
      display:grid;
      place-items:center;
      transition: transform .12s ease, background .2s ease;
    }
    .tile:hover{ transform: translateY(-1px); background: rgba(255,255,255,.68); }
    .tile.revealed{ background: rgba(45,212,191,.14); }
    .spark{
      position:absolute; inset:-40%;
      background:
        radial-gradient(circle at 30% 40%, rgba(45,212,191,.18), transparent 45%),
        radial-gradient(circle at 70% 60%, rgba(96,165,250,.14), transparent 45%);
      opacity:0;
      transform: rotate(12deg);
    }
    .tile.revealed .spark{ opacity:1; animation: spin 3.6s linear infinite; }
    @keyframes spin{
      from{ transform: rotate(0deg); }
      to{ transform: rotate(360deg); }
    }
    .tile span{
      font-size:12px;
      color: rgba(15,23,42,.72);
      opacity:.85;
    }
    .foundImg{
      width:60px; height:60px; object-fit:contain;
      filter: drop-shadow(0 10px 16px rgba(15,23,42,.16));
      opacity:.0;
      transform: translateY(6px) scale(.98);
      transition: opacity .25s ease, transform .25s ease;
    }
    .tile.found .foundImg{ opacity:1; transform: translateY(0) scale(1); }

    .overlay{
      position:fixed; inset:0;
      display:none;
      place-items:center;
      background: rgba(15,23,42,.45);
      backdrop-filter: blur(6px);
      z-index: 50;
      padding:18px;
    }
    .overlay.on{ display:grid; }
    .modal{
      width:min(720px, 96vw);
      background: rgba(255,255,255,.88);
      border:1px solid var(--line);
      border-radius: 18px;
      box-shadow: var(--shadow);
      overflow:hidden;
    }
    .modal .mhead{
      padding:12px 14px;
      border-bottom:1px solid var(--line);
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
    }
    .modal .mhead .mtitle{ font-weight:900; font-size:13px; letter-spacing:.02em; }
    .modal .mbody{ padding:14px; }
    .modal .mnote{ font-size:12px; color: var(--muted); line-height:1.7; }

    .thanks{
      min-height: 520px;
      display:grid;
      place-items:center;
      text-align:center;
    }
    .thanks .word{
      font-size: 34px;
      font-weight: 900;
      letter-spacing:.08em;
      color: rgba(15,23,42,.92);
      text-shadow: 0 18px 42px rgba(15,23,42,.12);
    }
    .fade{ animation: fadeIn 1.2s ease both; }
    @keyframes fadeIn{
      from{ opacity:0; transform: translateY(6px); }
      to{ opacity:1; transform: translateY(0); }
    }

    .tabs{ display:flex; gap:8px; flex-wrap:wrap; margin-top:12px; }
    .tab{
      padding:8px 10px;
      border-radius:999px;
      border:1px solid var(--line);
      background: rgba(255,255,255,.55);
      font-size:12px;
      color: rgba(15,23,42,.88);
      opacity:.95;
    }
    .tab.active{ background: rgba(96,165,250,.14); border-color: rgba(96,165,250,.28); }
    .logBox{
      margin-top:12px;
      border:1px solid var(--line);
      border-radius:18px;
      background: rgba(255,255,255,.55);
      padding:12px;
      overflow:auto;
      max-height: 360px;
    }
    .logLine{
      font-size:12px;
      line-height:1.8;
      color: rgba(15,23,42,.82);
      border-bottom:1px dashed rgba(15,23,42,.14);
      padding:6px 0;
    }
    .logLine:last-child{ border-bottom:0; }
    canvas{ max-width:100%; }

    .tiny{ font-size:12px; color: var(--muted); }

    .linkBox{
      margin-top:10px;
      padding:10px 12px;
      border-radius:14px;
      border:1px solid var(--line);
      background: rgba(255,255,255,.55);
      display:flex;
      gap:10px;
      align-items:center;
      justify-content:space-between;
      flex-wrap:wrap;
    }
    .linkBox input{
      flex:1;
      min-width: 240px;
      padding:10px 10px;
      border-radius:12px;
      background: rgba(255,255,255,.78);
      border:1px solid rgba(15,23,42,.14);
      color: rgba(15,23,42,.92);
      outline:none;
      font-size:12px;
    }

    select.sel{
      flex:1;
      min-width: 240px;
      padding:10px 10px;
      border-radius:12px;
      background: rgba(255,255,255,.78);
      border:1px solid rgba(15,23,42,.14);
      color: rgba(15,23,42,.92);
      outline:none;
      font-size:12px;
      appearance:none;
    }

    .cornerHint{
      position:absolute;
      top:10px; right:10px;
      font-size:12px;
      color: rgba(15,23,42,.70);
      opacity:.90;
      display:flex; align-items:center; gap:8px;
    }
    .toggle{
      width:42px; height:22px; border-radius:999px;
      background: rgba(15,23,42,.08);
      border:1px solid var(--line);
      position:relative;
      flex: 0 0 auto;
    }
    .toggle::after{
      content:"";
      width:18px; height:18px; border-radius:999px;
      position:absolute; top:1px; left:1px;
      background: rgba(15,23,42,.45);
      transition: left .18s ease, background .18s ease;
    }
    .toggle.on{ background: rgba(45,212,191,.22); border-color: rgba(45,212,191,.28); }
    .toggle.on::after{ left:21px; background: rgba(45,212,191,.92); }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="topbar">
      <div class="brand">
        <div class="dot"></div>
        <div>
          <div class="title">3日間のお世話ゲーム</div>
          <div class="sub" id="subline">記録だけが残る</div>
        </div>
      </div>
      <div class="navlinks" id="topNav">
        <button class="navbtn" id="btn_nav_start" type="button">スタート</button>
        <button class="navbtn" id="btn_nav_about" type="button">研究について</button>
        <button class="navbtn" id="btn_nav_lang" type="button">言語</button>
      </div>
      <div class="pill" id="modePill">
        <span id="modeLabel">プレイ</span>
        <small id="modeMeta">ローカル保存</small>
      </div>
    </div>

    <div class="screen active" id="scr_intro">
      <div class="grid">
        <div class="card">
          <div class="inner">
            <h2>はじめに</h2>
            <p class="fade">
              ある日、あなたのもとに一通のメッセージが届く。<br>
              「なくしたものを探しています。見つけた人に、3日間だけ預けます。」<br>
              地図だけが添えられている。
            </p>

            <p class="muted">
              最初に、あなたの相棒と、呼ばれたい名前を決める。<br>
              それから、マカロンの形をした「探しもの」を探しに行く。
            </p>

            <div style="margin-top:12px;">
              <div class="tiny" style="margin-bottom:6px;">呼ばれたい名前</div>
              <div class="btnrow" style="margin-top:0;">
                <input id="playerName" placeholder="○○（あなたの呼ばれ方）">
                <button class="btn blue" id="btn_start" disabled>はじめる</button>
                <button class="btn secondary" id="btn_new_reset" title="保存を消します">最初から</button>
              </div>
              <p class="tiny" style="margin-top:8px;">名前と選択はこの端末の中だけに保存されます。</p>

              <div style="margin-top:12px;">
                <div class="tiny" style="margin-bottom:6px;">時間設定</div>
                <div class="btnrow" style="margin-top:0;">
                  <select id="timeMode" class="sel">
                    <option value="normal">通常（誕生3分／寿命3日）</option>
                    <option value="fast">テスト（誕生約12秒／寿命約90秒）</option>
                  </select>
                </div>
                <p class="tiny" id="timeModeNote" style="margin-top:6px;"></p>
              </div>

              <div class="linkBox" id="resumeBox" style="display:none; margin-top:12px;">
                <div class="tiny">記録が残っています</div>
                <div class="btnrow" style="margin-top:8px;">
                  <button class="btn" id="btn_resume">つづきから</button>
                </div>
                <p class="tiny" id="resumeMeta" style="margin-top:6px;"></p>
              </div>
            </div>

            <p class="tiny" id="introNeed" style="margin-top:6px;"></p>
          </div>
        </div>

        <div class="card">
          <div class="stage">
            <div class="charWrap">
              <img id="charPreview" class="charImg floaty" alt="character preview" data-kind="char" data-color="green" data-state="open" />
            </div>
          </div>
          <div class="inner">
            <h2>相棒</h2>
            <p class="muted">正解はない。あなたが「この子」と思ったもの。</p>
            <div class="choiceGrid" id="charChoices"></div>
            <p class="tiny" id="introPickHint" style="margin-top:10px;">相棒を選ぶと、右の姿が少し変わります。</p>
          </div>
        </div>
      </div>
    </div>
    <div class="screen" id="scr_about">
      <div class="grid">
        <div class="card">
          <div class="inner">
            <h2 id="about_title">研究について</h2>

            <div id="about_ja">
              <p class="fade">
                これは、「3日間しか生きられないデジタルキャラクター」を世話することで、愛着・判断・別れを体験するための、小さなプロトタイプです。
                正解や評価は与えず、あなたが選んだことと、その日の記録だけが痕跡として残るように設計しています。
              </p>

              <p class="muted">
                このゲームで見えるのは、キャラクターの状態に見える「ふるまい」と、あなたの選択の連なりです。
                その意味づけは、あなた自身の解釈に委ねています。
              </p>

              <p class="muted">
                記録と状態は、この端末のブラウザに保存されます（localStorage）。
                ブラウザのデータを消すと、記録も消えます。
              </p>

              <p class="muted">
                シッターをONにすると時間が止まり、空腹や寿命の進行も止まります。
                「世話できなかった時間」を許すための機能です。
              </p>

              <p class="muted">
                マカロンとドリンクは、生と死の境界を少しだけ揺らすための道具です。
                復活はハッピーエンドとして扱わず、使用した事実だけがログに残ります。
              </p>

              <p class="tiny muted" style="margin-top:10px;">
                画像は public/stag1/ に置くと差し替えやすい構造です。
              </p>
            </div>

            <div id="about_en" style="display:none;">
              <p class="fade">
                This is a small prototype that explores attachment, decisions, and farewell by letting you care for a digital being that lives for only three days.
                There are no correct answers and no evaluations—only what you chose and what was recorded each day.
              </p>

              <p class="muted">
                What you can observe here is the character’s “behavior” (without explicit labels) and the sequence of your decisions.
                The meaning is left for you to interpret.
              </p>

              <p class="muted">
                The state and logs are stored only in your browser on this device (localStorage).
                If you clear browser data, the records will be removed.
              </p>

              <p class="muted">
                When the Sitter is ON, time stops—hunger, waste, mood shifts, and the life timer are all paused.
                This is meant to allow “time when you could not take care of them.”
              </p>

              <p class="muted">
                Macaron and Drink are tools that slightly disturb the boundary between life and death.
                A revival is not treated as a happy ending; only the fact of use remains in the log.
              </p>

              <p class="tiny muted" style="margin-top:10px;">
                You can replace images by putting files in public/stag1/.
              </p>
            </div>

            <div class="btnrow">
              <button class="btn secondary" id="btn_about_back" type="button">戻る</button>
            </div>
          </div>
        </div>
      </div>
    </div>

    <div class="screen" id="scr_lang">
      <div class="grid">
        <div class="card">
          <div class="inner">
            <h2 id="lang_title">言語</h2>

            <p class="muted">
              ここでは、上部メニューと「研究について」ページの表示言語を切り替えます。
              ゲーム本編の文章は、現在は日本語が中心です。
            </p>

            <div class="btnrow" style="gap:10px; flex-wrap:wrap;">
              <button class="btn" id="btn_lang_ja" type="button">日本語</button>
              <button class="btn secondary" id="btn_lang_en" type="button">English</button>
            </div>

            <p class="tiny muted" id="lang_status" style="margin-top:10px;">現在: 日本語</p>

            <div class="btnrow">
              <button class="btn secondary" id="btn_lang_back" type="button">戻る</button>
            </div>
          </div>
        </div>
      </div>
    </div>


    <div class="screen" id="scr_search">
      <div class="grid">
        <div class="card">
          <div class="inner">
            <h2>探す</h2>
            <p>現実と少しだけずれた空間。光の粒がゆっくり漂っている。</p>
            <p class="muted">どこかに、マカロンの形をしたものがある。</p>
            <div class="mapGrid" id="mapGrid"></div>
            <div class="btnrow">
              <button class="btn secondary" id="btn_back_intro">設定へ戻る</button>
              <button class="btn" id="btn_hint">少しだけ目を慣らす</button>
            </div>
          </div>
        </div>
        <div class="card">
          <div class="inner">
            <h2>気配</h2>
            <p class="muted" id="searchNote">まだ、何も見つからない。</p>
          </div>
        </div>
      </div>
    </div>

    <div class="screen" id="scr_arrival">
      <div class="grid">
        <div class="card">
          <div class="inner">
            <h2>到着</h2>
            <p id="arrivalText">
              見つけたマカロンを持ち帰った。<br>
              しばらくすると、ふわりと浮かび上がるらしい。
            </p>
            <p class="muted">誕生は、あなたの操作では起きない。</p>
            <div class="btnrow">
              <button class="btn secondary" id="btn_back_search">もう一度探す</button>
            </div>
          </div>
        </div>
        <div class="card">
          <div class="stage">
            <div class="charWrap">
              <img id="arrivalImg" class="charImg floaty" alt="macaron" data-kind="macaron" data-color="pink" />
            </div>
          </div>
        </div>
      </div>
    </div>

    <div class="screen" id="scr_care">
      <div class="grid">
        <div class="card">
          <div class="inner">
            <div style="display:flex; align-items:center; justify-content:space-between; gap:10px;">
              <h2 id="careTitle">いま</h2>
              <div style="display:flex; flex-direction:column; align-items:flex-end; gap:6px;">
                <div class="hearts" title="関係の雰囲気">
                  <div class="heart" id="h1"></div>
                  <div class="heart" id="h2"></div>
                  <div class="heart" id="h3"></div>
                  <div class="heart" id="h4"></div>
                  <div class="heart" id="h5"></div>
                </div>
                <div class="tiny" id="timeCounter" title="3日間の時間"></div>
              </div>
            </div>

            <p class="muted" id="careHint">言葉ではわからない。表情と動きだけが変わる。</p>

            <div class="btnrow" style="margin-top:10px;">
              <button class="btn" id="btn_food">食事</button>
              <button class="btn" id="btn_outing">お出かけ</button>
              <button class="btn" id="btn_mini">つまらないゲーム</button>
              <button class="btn" id="btn_clean">排泄除去</button>
              <button class="btn blue" id="btn_drink">ドリンク</button>
              <button class="btn danger" id="btn_macaron">マカロン</button>
              <button class="btn secondary" id="btn_logs">ログ</button>
            </div>

            <div class="linkBox" style="margin-top:12px;">
              <div class="tiny">シッター</div>
              <div style="display:flex; align-items:center; gap:10px;">
                <div class="toggle" id="toggle_sitter" role="switch" aria-checked="false" tabindex="0"></div>
                <div class="tiny" id="sitterNote">時間は止まる</div>
              </div>
            </div>

            <p class="tiny" id="endNote" style="margin-top:10px; display:none;">
              ここから先は、操作できない。記録だけが残る。
            </p>
          </div>
        </div>

        <div class="card">
          <div class="stage">
            <div class="charWrap" id="charWrap">
              <div class="charPair k-ok" id="charPair" aria-hidden="true">
                <img id="charImg" class="charTwin left" alt="character left" data-kind="char" data-color="green" data-state="open" />
                <img id="charImg2" class="charTwin right" alt="character right" data-kind="char" data-color="blue" data-state="open" />
              </div>
              <div class="tear" id="tear"></div>
              <div class="poop" id="po1"></div>
              <div class="poop" id="po2"></div>
              <div class="poop" id="po3"></div>
              <div class="poop" id="po4"></div>
            </div>
          </div>
        </div>
      </div>
    </div>

    <div class="screen" id="scr_end">
      <div class="card">
        <div class="thanks">
          <div>
            <div class="word fade">ありがとう</div>
            <div class="btnrow" style="justify-content:center; margin-top:16px;">
              <button class="btn secondary" id="btn_end_logs">ログを見る</button>
            </div>
          </div>
        </div>
      </div>
    </div>

    <div class="screen" id="scr_logs">
      <div class="grid">
        <div class="card">
          <div class="inner">
            <h2>ログ</h2>
            <p class="muted">評価はしない。起きたことだけ。</p>

            <canvas id="heartChart" width="640" height="180" style="margin-top:10px; border:1px solid var(--line); border-radius:16px; background: rgba(255,255,255,.70);"></canvas>

            <div class="tabs" id="dayTabs"></div>

            <div class="logBox" id="logBox"></div>

            <div class="btnrow">
              <button class="btn secondary" id="btn_back_care">戻る</button>
            </div>
          </div>
        </div>
      </div>
    </div>

  </div>

  <div class="overlay" id="overlay">
    <div class="modal">
      <div class="mhead">
        <div class="mtitle" id="modalTitle">選ぶ</div>
        <button class="btn secondary" id="btn_close_modal">閉じる</button>
      </div>
      <div class="mbody" id="modalBody">
        <div class="mnote" id="modalNote"></div>
        <div class="btnrow" id="modalBtns"></div>
      </div>
    </div>
  </div>

<script>
(() => {
  const APP_KEY = "care3days_save_stage1_v2";


  // 画像アセットの置き場所とファイル名は環境差が出やすいので、
// 「public/stag1/ に置けば表示できる」を崩さないまま、よくある命名揺れも自動で拾います。
const ASSET_BASE_CANDIDATES = [
  "public/stag1/","./public/stag1/",
  "public/stage1/","./public/stage1/",
  "public/char/","./public/char/",
  "stag1/","./stag1/",
  "stage1/","./stage1/",
  "char/","./char/"
];

// 最後に見つかった base（見つからない場合でも動くように初期値だけ入れておく）
let ASSET_BASE = ASSET_BASE_CANDIDATES[0];

// 解決済みURLのキャッシュ（存在しない場合は "" を入れる）
const RESOLVED_ASSETS = {
  char:   { green:{}, blue:{}, pink:{}, purple:{}, any:{} },
  macaron:{ green:"", blue:"", pink:"", purple:"", any:"" },
  drink:  { green:"", blue:"", pink:"", purple:"", any:"" }
};

// いま解決中のキー（同じものを何度も探さない）
const RESOLVING_KEYS = new Set();

function _assetKey(kind, color, state){
  return kind + ":" + (color || "any") + ":" + (state || "");
}

// 拡張子をまとめて試すためのユーティリティ
function _withExts(stems){
  const exts = ["png","webp","jpg","jpeg"];
  const out = [];
  stems.forEach(stem => {
    if(!stem) return;
    if(/\.(png|webp|jpg|jpeg)$/i.test(stem)){
      out.push(stem);
    }else{
      exts.forEach(ex => out.push(stem + "." + ex));
    }
  });
  return out;
}

// キャラ画像の候補（あなたの public/stag1/ の命名に合わせて、必要ならここだけ増やせます）
function _charFileCandidates(color, state){
  const c = color || "green";
  const openNames   = ["open","awake","normal","happy","smile","on"];
  const closedNames = ["closed","close","sleep","rest","idle","off"];

  const names = (state === "closed") ? closedNames : openNames;
  const stems = [];

  // 例：pink_open / pink-closed / pink/open / stage1_pink_open など
  names.forEach(n => {
    stems.push(`${c}_${n}`);
    stems.push(`${c}-${n}`);
    stems.push(`${c}${n}`);
    stems.push(`${c}/${n}`);
    stems.push(`${c}/${c}_${n}`);
    stems.push(`tane_${c}_${n}`);
    stems.push(`tane-${c}-${n}`);
    stems.push(`${c}_tane_${n}`);
    stems.push(`stage1_${c}_${n}`);
    stems.push(`stag1_${c}_${n}`);
    stems.push(`${c}_${n}_stage1`);
    stems.push(`${c}_${n}_stag1`);
  });

  // stateが無い単体名も拾う（例：tane_pink / pink / stage1_pink）
  stems.push(`tane_${c}`);
  stems.push(`${c}_tane`);
  stems.push(`stage1_${c}`);
  stems.push(`stag1_${c}`);
  stems.push(`character_${c}`);
  stems.push(`pet_${c}`);
  stems.push(`${c}`);

  // 過去に出てきた名前も一応試す
  stems.push(`pink_open`); //（色固定の名残がある場合）
  stems.push(`${c}_open`);
  stems.push(`${c}_closed`);
  stems.push(`${c}_egg`);
  stems.push(`tane_${c}`);
  stems.push(`seed_${c}`);
  stems.push(`seed_${c}_open`);
  stems.push(`seed_${c}_closed`);

  // 重複除去して返す
  const uniq = [...new Set(stems)];
  return _withExts(uniq);
}

function _macaronFileCandidates(color){
  const c = color || "green";
  const stems = [
    `macaron_${c}`,
    `macaron-${c}`,
    `${c}_macaron`,
    `item_macaron_${c}`,
    `macaron`,
    `macaroon_${c}`,
    `macaroon`
  ];
  return _withExts([...new Set(stems)]);
}

function _drinkFileCandidates(color){
  const c = color || "green";
  const stems = [
    `drink_${c}`,
    `drink-${c}`,
    `${c}_drink`,
    `item_drink_${c}`,
    `drink`,
    `potion_${c}`,
    `potion`
  ];
  return _withExts([...new Set(stems)]);
}

// いまのDOM内の画像（data-kind付き）をまとめて更新
function refreshBoundImages(){
  document.querySelectorAll('img[data-kind]').forEach(img => {
    const kind  = img.dataset.kind;
    const color = img.dataset.color || "green";
    const state = img.dataset.state || (kind === "char" ? "open" : "");
    const src = getAssetSrc(kind, color, state);
    if(src && img.src !== src) img.src = src;
  });
}

// 画像が見つからないときはSVGに差し替えて「破れたアイコン」を出さない
function getFallbackSrc(kind, color, state){
  if(kind === "macaron"){
    return (FALLBACK.macaron[color] || FALLBACK.macaron.green);
  }
  if(kind === "drink"){
    // ドリンク用の簡易SVG（なければマカロンに寄せる）
    return svgDataUri(`<svg xmlns="http://www.w3.org/2000/svg" width="256" height="256" viewBox="0 0 256 256">
      <rect x="80" y="40" width="96" height="176" rx="24" fill="#e5e7eb" stroke="#6b7280" stroke-width="6"/>
      <path d="M96 92 h64" stroke="#6b7280" stroke-width="6" stroke-linecap="round"/>
      <path d="M96 128 h64" stroke="#6b7280" stroke-width="6" stroke-linecap="round"/>
      <circle cx="128" cy="72" r="10" fill="#6b7280"/>
    </svg>`);
  }
  const pack = (FALLBACK.char[color] || FALLBACK.char.green);
  return pack[state] || pack.open;
}

// 今すぐ使う同期版：解決済みがあれば返し、無ければ探索を開始してフォールバックを返す
function getAssetSrc(kind, color, state){
  const k = kind || "char";
  const c = color || "green";

  if(k === "char"){
    const st = state || "open";
    const cached = (RESOLVED_ASSETS.char[c] && RESOLVED_ASSETS.char[c][st]) || (RESOLVED_ASSETS.char.any && RESOLVED_ASSETS.char.any[st]);
    if(cached) return cached;

    const key = _assetKey("char", c, st);
    if(!RESOLVING_KEYS.has(key)){
      RESOLVING_KEYS.add(key);
      resolveAsset("char", c, st).then(url => {
        RESOLVED_ASSETS.char[c][st] = url || "";
        RESOLVING_KEYS.delete(key);
        refreshBoundImages();
      });
    }
    return getFallbackSrc("char", c, st);
  }

  if(k === "macaron"){
    const cached = RESOLVED_ASSETS.macaron[c] || RESOLVED_ASSETS.macaron.any;
    if(cached) return cached;

    const key = _assetKey("macaron", c, "");
    if(!RESOLVING_KEYS.has(key)){
      RESOLVING_KEYS.add(key);
      resolveAsset("macaron", c, "").then(url => {
        RESOLVED_ASSETS.macaron[c] = url || "";
        RESOLVING_KEYS.delete(key);
        refreshBoundImages();
      });
    }
    return getFallbackSrc("macaron", c, "");
  }

  if(k === "drink"){
    const cached = RESOLVED_ASSETS.drink[c] || RESOLVED_ASSETS.drink.any;
    if(cached) return cached;

    const key = _assetKey("drink", c, "");
    if(!RESOLVING_KEYS.has(key)){
      RESOLVING_KEYS.add(key);
      resolveAsset("drink", c, "").then(url => {
        RESOLVED_ASSETS.drink[c] = url || "";
        RESOLVING_KEYS.delete(key);
        refreshBoundImages();
      });
    }
    return getFallbackSrc("drink", c, "");
  }

  // 不明な種類は安全にフォールバック
  return getFallbackSrc("char", c, state || "open");
}

// 実際に「どこに何があるか」を探す（base候補×ファイル候補）
async function resolveAsset(kind, color, state){
  // 保存された base があれば最優先にする
  const savedBase = (save && save.config && save.config.assetBase) ? save.config.assetBase : null;
  const bases = [];
  if(savedBase) bases.push(savedBase);
  ASSET_BASE_CANDIDATES.forEach(b => { if(!bases.includes(b)) bases.push(b); });

  let files = [];
  if(kind === "char"){
    files = _charFileCandidates(color, state);
  }else if(kind === "macaron"){
    files = _macaronFileCandidates(color);
  }else if(kind === "drink"){
    files = _drinkFileCandidates(color);
  }

  // 先に base が確定できたら、次回から高速化できる
  for(const base of bases){
    for(const f of files){
      const url = base + f;
      if(await checkImage(url)){
        ASSET_BASE = base;
        if(save){
          if(!save.config) save.config = {};
          save.config.assetBase = base;
          saveNow();
        }
        return url;
      }
    }
  }

  // 見つからない場合は空を返す（呼び出し側がフォールバックを使う）
  return "";
}

  function svgDataUri(svg){
    return "data:image/svg+xml;charset=utf-8," + encodeURIComponent(svg);
  }

  function charSvg(color, eyes){
    const palette = {
      green:  ["#7dd3a8","#1f7a52"],
      blue:   ["#93c5fd","#1e40af"],
      pink:   ["#f9a8d4","#9d174d"],
      purple: ["#c4b5fd","#5b21b6"]
    };
    const [fill, stroke] = palette[color] || palette.green;

    const eye = (eyes === "open")
      ? `<circle cx="102" cy="110" r="8" fill="${stroke}"/><circle cx="154" cy="110" r="8" fill="${stroke}"/>`
      : `<path d="M92 110 q10 10 20 0" stroke="${stroke}" stroke-width="6" fill="none" stroke-linecap="round"/>
         <path d="M144 110 q10 10 20 0" stroke="${stroke}" stroke-width="6" fill="none" stroke-linecap="round"/>`;

    const mouth = (eyes === "open")
      ? `<path d="M112 148 q16 14 32 0" stroke="${stroke}" stroke-width="6" fill="none" stroke-linecap="round"/>`
      : `<path d="M116 152 q12 -10 24 0" stroke="${stroke}" stroke-width="6" fill="none" stroke-linecap="round"/>`;

    const svg = `
      <svg xmlns="http://www.w3.org/2000/svg" width="256" height="256" viewBox="0 0 256 256">
        <defs>
          <radialGradient id="g" cx="35%" cy="30%" r="75%">
            <stop offset="0%" stop-color="#ffffff" stop-opacity="0.95"/>
            <stop offset="35%" stop-color="${fill}" stop-opacity="0.95"/>
            <stop offset="100%" stop-color="${fill}" stop-opacity="1"/>
          </radialGradient>
        </defs>
        <circle cx="128" cy="132" r="92" fill="url(#g)" stroke="${stroke}" stroke-width="6"/>
        <circle cx="92" cy="84" r="10" fill="#fff" opacity="0.9"/>
        <circle cx="168" cy="76" r="6" fill="#fff" opacity="0.65"/>
        ${eye}
        ${mouth}
      </svg>
    `;
    return svgDataUri(svg);
  }

  function macaronSvg(color){
    const palette = {
      green:  ["#86efac","#166534"],
      blue:   ["#bfdbfe","#1e3a8a"],
      pink:   ["#fbcfe8","#9d174d"],
      purple: ["#ddd6fe","#4c1d95"]
    };
    const [fill, stroke] = palette[color] || palette.green;
    const svg = `
      <svg xmlns="http://www.w3.org/2000/svg" width="256" height="256" viewBox="0 0 256 256">
        <rect x="56" y="92" width="144" height="78" rx="26" fill="${fill}" stroke="${stroke}" stroke-width="6"/>
        <path d="M62 132 q66 -16 132 0" fill="none" stroke="${stroke}" stroke-width="6" opacity="0.4"/>
        <rect x="64" y="114" width="128" height="40" rx="18" fill="#fff" opacity="0.35"/>
        <circle cx="110" cy="132" r="7" fill="${stroke}"/>
        <circle cx="146" cy="132" r="7" fill="${stroke}"/>
        <path d="M118 150 q10 10 20 0" stroke="${stroke}" stroke-width="6" fill="none" stroke-linecap="round"/>
      </svg>
    `;
    return svgDataUri(svg);
  }

  const FALLBACK = {
    char: {
      green:  { open: charSvg("green","open"),  closed: charSvg("green","closed") },
      blue:   { open: charSvg("blue","open"),   closed: charSvg("blue","closed")  },
      pink:   { open: charSvg("pink","open"),   closed: charSvg("pink","closed")  },
      purple: { open: charSvg("purple","open"), closed: charSvg("purple","closed") }
    },
    macaron: {
      green:  macaronSvg("green"),
      blue:   macaronSvg("blue"),
      pink:   macaronSvg("pink"),
      purple: macaronSvg("purple")
    }
  };

  // IMGの読み込み失敗時、色に応じたSVGへ差し替え
  document.addEventListener("error", (ev) => {
    const el = ev.target;
    if(!el || el.tagName !== "IMG") return;
    if(el.dataset.fallbackApplied === "1") return;

    const kind = el.dataset.kind || "char";
    const color = el.dataset.color || "green";
    const state = el.dataset.state || "open";

    // まずは「別名の画像」を順に試す（リポジトリ内のファイル名が違っても拾えるように）
    function buildCandidates(){
      const exts = ["png","webp","jpg","jpeg"];
      const files = [];
      const push = (tpl) => exts.forEach(e => files.push(tpl.replace("{c}", color).replace("{e}", e)));

      if(kind === "macaron"){
        [
          "macaron_{c}.{e}",
          "{c}_macaron.{e}",
          "mac_{c}.{e}",
          "m_{c}.{e}"
        ].forEach(push);
      }else{
        const common = [
          "{c}.{e}",
          "tane_{c}.{e}",
          "{c}_tane.{e}",
          "{c}_egg.{e}",
          "{c}_seed.{e}"
        ];
        if(state === "open"){
          ["{c}_open.{e}", "open_{c}.{e}"].forEach(push);
          common.forEach(push);
        }else{
          ["{c}_closed.{e}", "closed_{c}.{e}", "{c}_open.{e}"].forEach(push);
          common.forEach(push);
        }
      }
      return files;
    }

    // 候補URL（base候補×ファイル候補）を初回だけ生成
    if(!el.dataset.candidateUrls){
      const bases = [];
      const saved = (save && save.config && save.config.assetBase) ? save.config.assetBase : null;
      if(saved) bases.push(saved);
      if(ASSET_BASE) bases.push(ASSET_BASE);
      (ASSET_BASE_CANDIDATES || []).forEach(b => { if(bases.indexOf(b) === -1) bases.push(b); });

      const files = buildCandidates();
      const urls = [];
      bases.forEach(b => files.forEach(f => urls.push(b + f)));

      // 重複除去＆今のsrcは除外
      const cur = (el.src || "").split("?")[0];
      const uniq = [];
      const seen = new Set();
      urls.forEach(u => {
        const key = u.split("?")[0];
        if(key === cur) return;
        if(seen.has(key)) return;
        seen.add(key);
        uniq.push(u);
      });

      el.dataset.candidateUrls = JSON.stringify(uniq);
      el.dataset.candidateIndex = "0";
    }

    try{
      const arr = JSON.parse(el.dataset.candidateUrls || "[]");
      const idx = parseInt(el.dataset.candidateIndex || "0", 10);

      if(idx < arr.length){
        el.dataset.candidateIndex = String(idx + 1);
        el.src = arr[idx];
        return;
      }
    }catch(e){
      // ここは黙ってフォールバックへ
    }

    // 最後の手段：SVGに差し替え（破れた画像を残さない）
    let src = null;
    if(kind === "macaron"){
      src = (FALLBACK.macaron[color] || FALLBACK.macaron.green);
    }else{
      const pack = (FALLBACK.char[color] || FALLBACK.char.green);
      src = pack[state] || pack.open;
    }

    if(src){
      el.dataset.fallbackApplied = "1";
      el.src = src;
    }
  }, true);



  // 画像が存在するか軽くチェック（GitHub Pagesでも動くように Image で判定）
  // 画像が存在するか軽くチェック（GitHub Pagesでも動くように Image で判定）
// url単位でキャッシュして、無駄な試行を減らします
const _imgExistsCache = new Map();
function checkImage(url){
  if(_imgExistsCache.has(url)) return Promise.resolve(_imgExistsCache.get(url));
  return new Promise((resolve) => {
    const img = new Image();
    img.onload = () => { _imgExistsCache.set(url, true); resolve(true); };
    img.onerror = () => { _imgExistsCache.set(url, false); resolve(false); };
    // キャッシュで誤判定しないように少しだけバージョンを付ける
    const u = url + (url.includes("?") ? "&" : "?") + "v=" + Date.now();
    img.src = u;
  });
}

  // 保存にassetBaseがあればそれを優先します（ファイル名揺れは resolveAsset が吸収します）
async function detectAssetBase(){
  const saved = save && save.config && save.config.assetBase ? save.config.assetBase : null;
  if(saved){
    ASSET_BASE = saved;
    return saved;
  }
  ASSET_BASE = ASSET_BASE_CANDIDATES[0];
  if(save){
    if(!save.config) save.config = {};
    save.config.assetBase = ASSET_BASE;
    saveNow();
  }
  return ASSET_BASE;
}


  const DAY_MS = 24*60*60*1000;
  const LIFE_MS = 3*DAY_MS;

  // 誕生は時間経過で起こす（3分）
  const HATCH_MS = 3*60*1000;

  // 時間設定（テスト用に短縮もできる）
// URLに ?fast=1 を付けると一時的にテストモードになります
const url = new URL(location.href);
// 共有URL（観察用）は廃止したので、古いURLパラメータは静かに取り除く
if(url.searchParams.get("observe") || url.searchParams.get("data")){
  url.searchParams.delete("observe");
  url.searchParams.delete("data");
  try{ history.replaceState({}, "", url.toString()); }catch(e){}
}
const TIME_MODE_KEY = "care3days_timeMode";
const baseMode = (url.searchParams.get("fast") === "1") ? "fast" : ((localStorage.getItem(TIME_MODE_KEY) === "fast") ? "fast" : "normal");

function inferFastFromSave(s){
  try{
    if(s && s.life && s.life.bornAt && s.life.deathAt){
      const d = s.life.deathAt - s.life.bornAt;
      if(d > 0 && d < 10*60*1000) return true;
    }
    if(s && s.story && s.story.hatchAt && s.story.arrivalAt){
      const d = s.story.hatchAt - s.story.arrivalAt;
      if(d > 0 && d < 60*1000) return true;
    }
  }catch(e){}
  return baseMode === "fast";
}

function isFast(s){
  const obj = s || save;
  if(obj && obj.config && typeof obj.config.fast === "boolean") return obj.config.fast;
  return baseMode === "fast";
}
function hatchMsEff(s){ return isFast(s) ? 12*1000 : HATCH_MS; }
function lifeMsEff(s){ return isFast(s) ? 90*1000 : LIFE_MS; }
function dayMsEff(s){ return lifeMsEff(s) / 3; }

  const $ = (id) => document.getElementById(id);
  const screens = {
    intro: $("scr_intro"),
    about: $("scr_about"),
    lang: $("scr_lang"),
    search: $("scr_search"),
    arrival: $("scr_arrival"),
    care: $("scr_care"),
    end: $("scr_end"),
    logs: $("scr_logs")
  };

  const modeLabel = $("modeLabel");
  const modeMeta = $("modeMeta");
  const subline = $("subline");

  // 言語（上部メニューと「研究について」ページの表示だけ切替）
  const LANG_KEY = "care3days_lang";
  let lang = localStorage.getItem(LANG_KEY) || "ja";

  const I18N = {
    ja: {
      nav_start: "スタート",
      nav_about: "研究について",
      nav_lang: "言語",
      about_title: "研究について",
      lang_title: "言語",
      back: "戻る",
      mode_play: "プレイ",
      mode_local: "ローカル保存",
      subline: "記録だけが残る",
      lang_status: "現在: 日本語"
    },
    en: {
      nav_start: "Start",
      nav_about: "About",
      nav_lang: "Language",
      about_title: "About this research",
      lang_title: "Language",
      back: "Back",
      mode_play: "Play",
      mode_local: "Local save",
      subline: "Only traces remain",
      lang_status: "Current: English"
    }
  };

  function getT(){ return I18N[lang] || I18N.ja; }

  function applyLang(){
    const t = getT();

    // 上部メニュー
    const bStart = $("btn_nav_start");
    const bAbout = $("btn_nav_about");
    const bLang  = $("btn_nav_lang");
    if(bStart) bStart.textContent = t.nav_start;
    if(bAbout) bAbout.textContent = t.nav_about;
    if(bLang)  bLang.textContent  = t.nav_lang;

    // タイトル
    const aboutTitle = $("about_title");
    const langTitle  = $("lang_title");
    if(aboutTitle) aboutTitle.textContent = t.about_title;
    if(langTitle)  langTitle.textContent  = t.lang_title;

    // 戻るボタン
    const backAbout = $("btn_about_back");
    const backLang  = $("btn_lang_back");
    if(backAbout) backAbout.textContent = t.back;
    if(backLang)  backLang.textContent  = t.back;

    // 「研究について」本文（日本語/英語の切替）
    const aboutJa = $("about_ja");
    const aboutEn = $("about_en");
    if(aboutJa && aboutEn){
      const isEn = (lang === "en");
      aboutJa.style.display = isEn ? "none" : "block";
      aboutEn.style.display = isEn ? "block" : "none";
    }

    // 言語ページの現在表示
    const status = $("lang_status");
    if(status) status.textContent = t.lang_status;

    // html lang
    document.documentElement.lang = (lang === "en") ? "en" : "ja";
  }

  function initTopNav(){
    // すでに初期化済みなら二重登録しない
    if(initTopNav._done) return;
    initTopNav._done = true;

    const bStart = $("btn_nav_start");
    const bAbout = $("btn_nav_about");
    const bLang  = $("btn_nav_lang");

    if(bStart) bStart.addEventListener("click", () => showScreen("intro"));
    if(bAbout) bAbout.addEventListener("click", () => showScreen("about"));
    if(bLang)  bLang.addEventListener("click",  () => showScreen("lang"));

    const backAbout = $("btn_about_back");
    const backLang  = $("btn_lang_back");
    if(backAbout) backAbout.addEventListener("click", () => showScreen("intro"));
    if(backLang)  backLang.addEventListener("click",  () => showScreen("intro"));

    const ja = $("btn_lang_ja");
    const en = $("btn_lang_en");
    if(ja) ja.addEventListener("click", () => {
      lang = "ja";
      localStorage.setItem(LANG_KEY, lang);
      applyLang();
      setModePill();
    });
    if(en) en.addEventListener("click", () => {
      lang = "en";
      localStorage.setItem(LANG_KEY, lang);
      applyLang();
      setModePill();
    });
  }

  const overlay = $("overlay");
  const modalTitle = $("modalTitle");
  const modalNote = $("modalNote");
  const modalBtns = $("modalBtns");

  let save = null;
  let tickTimer = null;

  function clamp(n, a, b){ return Math.max(a, Math.min(b, n)); }
  function rnd(a,b){ return a + Math.random()*(b-a); }
  function nowMs(){ return Date.now(); }

  // シッター中は時間が停止する（内部時間だけ止める）
  function effectiveNow(s){
    if(!s) return nowMs();
    const baseNow = nowMs();
    const pauseExtra = s.sitter.on ? (baseNow - s.sitter.onSince) : 0;
    return baseNow - s.sitter.pausedTotal - pauseExtra;
  }

  function dayIndex(s){
    if(!s || !s.life.bornAt) return 0;
    const t = effectiveNow(s) - s.life.bornAt;
    const d = Math.floor(t / dayMsEff(s)) + 1;
    return clamp(d, 1, 3);
  }

  // 3日間の残り時間（シッター停止分は差し引かれる）
  function remainingMs(s){
    if(!s || !s.life || !s.life.bornAt) return null;
    const t = effectiveNow(s);
    if(s.life.revivedUntil){
      return Math.max(0, s.life.revivedUntil - t);
    }
    if(s.life.isEnded) return 0;
    return Math.max(0, s.life.deathAt - t);
  }

  // 数値で追い詰めないために、秒は基本出さない（テストモードだけ秒表示）
  function formatRemainingMs(ms){
    if(ms == null) return "";
    if(ms <= 0) return "残り 0分";

    // テスト用：短いので秒まで出す
    if(isFast(save)){
      const sec = Math.ceil(ms/1000);
      if(sec < 60) return `残り ${sec}s`;
      const m = Math.floor(sec/60);
      const s = sec % 60;
      return `残り ${m}m${String(s).padStart(2,"0")}s`;
    }

    const mins = Math.ceil(ms/60000);
    const days = Math.floor(mins/(60*24));
    const hrs = Math.floor((mins - days*24*60)/60);
    const m = mins % 60;

    if(days > 0) return `残り ${days}日${hrs}時間`;
    if(hrs > 0) return `残り ${hrs}時間${m}分`;
    return `残り ${m}分`;
  }

  function showScreen(name){
    Object.values(screens).filter(Boolean).forEach(el => el.classList.remove("active"));
    (screens[name] || null) && screens[name].classList.add("active");
  }

  function setModePill(){
    const t = (typeof getT === "function") ? getT() : { mode_play:"プレイ", mode_local:"ローカル保存", subline:"記録だけが残る" };
    modeLabel.textContent = t.mode_play;
    modeMeta.textContent = t.mode_local;
    subline.textContent = t.subline;
  }

  function safeJSONParse(str, fallback){
    try{ return JSON.parse(str); }catch(e){ return fallback; }
  }

  function emptyDay(d){
    return {
      day: d,
      heartStart: null,
      heartEnd: null,
      sitterMs: 0,
      careCounts: { food:0, outing:0, mini:0, clean:0, drink:0, macaron:0 },
      choices: { food:[], outing:[], mini:[], clean:[] }
    };
  }

  function genId(){
    return "p" + Math.random().toString(36).slice(2,10) + "-" + Date.now().toString(36);
  }

  function newSave(){
    const id = genId();
    const t = nowMs();
    return {
      v: 2,
      config: { fast: (baseMode === 'fast'), timeMode: (baseMode === 'fast' ? 'fast' : 'normal') },
      id,
      playerName: "",
      startedAt: t,
      story: {
        chosenColor: null,
      twinColor: null,
        foundAt: null,
        arrivalAt: null,
        hatchAt: null,
        hatched: false,
        _targetTile: null,
        _revealed: []
      },
      life: {
        bornAt: null,
        deathAt: null,
        endedAt: null,
        isEnded: false,
        revivedUntil: null,
        uncanny: false,
        _handledEnd: false
      },
      stats: {
        hunger: 30,
        waste: 20,
        mood: 70,
        hearts: 55,
        boringPlays: 0,
        boringMilestone: 0
      },
      sitter: {
        on: false,
        onSince: null,
        pausedTotal: 0,
        usedTotal: 0
      },
      items: {
        drink: 2,
        macaron: 1
      },
      logs: {
        day: { "1": emptyDay(1), "2": emptyDay(2), "3": emptyDay(3) },
        events: []
      },
      _lastEff: t,
      _prevDay: 0
    };
  }

  function loadSave(){
    const raw = localStorage.getItem(APP_KEY);
    if(raw){
      const parsed = safeJSONParse(raw, null);
      if(parsed && (parsed.v === 2)) return parsed;
    }
    return newSave();
  }

  function saveNow(){
    localStorage.setItem(APP_KEY, JSON.stringify(save));
  }

  function resetAll(){
    localStorage.removeItem(APP_KEY);
    save = newSave();
    saveNow();
  }

  function addEvent(type, detail){
    const t = effectiveNow(save);
    const d = dayIndex(save) || 1;
    save.logs.events.push({ t, day:d, type, detail });

    const dayObj = save.logs.day[String(d)] || null;
    if(dayObj){
      if(type === "food"){ dayObj.careCounts.food++; dayObj.choices.food.push(detail.choice); }
      if(type === "outing"){ dayObj.careCounts.outing++; dayObj.choices.outing.push(detail.choice); }
      if(type === "mini"){ dayObj.careCounts.mini++; dayObj.choices.mini.push(detail.choice); }
      if(type === "clean"){ dayObj.careCounts.clean++; dayObj.choices.clean.push(detail.choice); }
      if(type === "drink"){ dayObj.careCounts.drink++; }
      if(type === "macaron"){ dayObj.careCounts.macaron++; }
      if(type === "sitterOn" || type === "sitterOff"){
        // sitterMs は切り替え時に更新
      }
    }
  }

  function formatTime(ms){
    const dt = new Date(ms);
    const hh = String(dt.getHours()).padStart(2,"0");
    const mm = String(dt.getMinutes()).padStart(2,"0");
    return `${hh}:${mm}`;
  }

  function ensureDayHearts(){
    if(!save.life.bornAt) return;
    const d = dayIndex(save);
    const dayObj = save.logs.day[String(d)];
    if(dayObj && dayObj.heartStart == null){
      dayObj.heartStart = save.stats.hearts;
    }
  }

  function finalizeDayIfNeeded(prevDay, nextDay){
    if(prevDay === 0 || prevDay === nextDay) return;
    const prevObj = save.logs.day[String(prevDay)];
    if(prevObj && prevObj.heartEnd == null){
      prevObj.heartEnd = save.stats.hearts;
    }
    const nextObj = save.logs.day[String(nextDay)];
    if(nextObj && nextObj.heartStart == null){
      nextObj.heartStart = save.stats.hearts;
    }
  }

  function finalizeAllDaysAtEnd(){
    for(let d=1; d<=3; d++){
      const obj = save.logs.day[String(d)];
      if(obj.heartStart == null && d===1) obj.heartStart = save.stats.hearts;
      if(obj.heartEnd == null) obj.heartEnd = save.stats.hearts;
    }
  }

  function prettyColor(c){
    if(c==="green") return "みどり";
    if(c==="blue") return "あお";
    if(c==="pink") return "もも";
    if(c==="purple") return "むらさき";
    return c;
  }

  function pickTwinColor(primary){
    const colors = ["green","blue","pink","purple"];
    const opts = colors.filter(x => x !== primary);
    return opts[Math.floor(Math.random()*opts.length)] || "blue";
  }

  function ensureTwinColors(){
    if(!save || !save.story || !save.story.chosenColor) return;
    const a = save.story.chosenColor;
    if(!save.story.twinColor || save.story.twinColor === a){
      save.story.twinColor = pickTwinColor(a);
      saveNow();
    }

  // ログからミニゲーム回数を推定（古い保存データの救済用）
  function estimateMiniPlaysFromLogs(s){
    try{
      if(!s || !s.logs || !s.logs.day) return 0;
      let n = 0;
      for(let d=1; d<=3; d++){
        const obj = s.logs.day[String(d)];
        if(obj && obj.careCounts && typeof obj.careCounts.mini === "number") n += obj.careCounts.mini;
      }
      return n;
    }catch(e){ return 0; }
  }

  }

function normalizeSaveConfig(){
  if(!save) return;
  if(!save.config) save.config = {};
  if(typeof save.config.fast !== "boolean") save.config.fast = inferFastFromSave(save);
  if(!save.config.timeMode) save.config.timeMode = save.config.fast ? "fast" : "normal";
  // 古い保存データでも2体が同色にならないように
  ensureTwinColors();
  // 設定の既定値を端末側にも残す（次回の初期値）
    // 古い保存データ用：統計フィールドの補完
  if(!save.stats) save.stats = { hunger:30, waste:20, mood:70, hearts:55 };
  if(typeof save.stats.boringPlays !== "number"){
    // 既存ログから推定（なければ0）
    save.stats.boringPlays = estimateMiniPlaysFromLogs(save);
  }
  if(typeof save.stats.boringMilestone !== "number"){
    save.stats.boringMilestone = Math.floor((save.stats.boringPlays||0)/20);
  }
try{ localStorage.setItem(TIME_MODE_KEY, save.config.fast ? "fast" : "normal"); }catch(e){}
}

  function wireTimeModeSelect(){
  const sel = $('timeMode');
  const note = $('timeModeNote');
  if(!sel || !note) return;

  // 進行している場合は、途中で切り替えると時刻がずれるので無効化
  const progressed = !!(save && (save.story.foundAt || save.story.arrivalAt || save.life.bornAt || save.life.isEnded));
  sel.disabled = progressed;

  const curMode = (save && save.config && save.config.fast) ? 'fast' : 'normal';
  sel.value = curMode;

  const setNote = (mode) => {
    if(progressed){
      note.textContent = '途中からは変えられません。新しく始めるときに設定できます。';
    }else{
      note.textContent = (mode==='fast') ? 'テスト用：誕生と3日間が短く進みます。' : '通常：誕生は3分、寿命は3日です。';
    }
  };
  setNote(sel.value);

  sel.onchange = () => {
    const mode = sel.value;
    try{ localStorage.setItem(TIME_MODE_KEY, mode); }catch(e){}
    if(save && !progressed){
      if(!save.config) save.config = {};
      save.config.fast = (mode === 'fast');
      save.config.timeMode = mode;
      saveNow();
    }
    setNote(mode);
  };
}

function renderOnboarding(){
    showScreen("intro");

    const box = $("charChoices");
    const preview = $("charPreview");
    if(!box || !preview) return;

    box.innerHTML = "";
    const colors = ["green","blue","pink","purple"];
    const desc = {
      green: "風が通るみたいに、軽い。",
      blue: "静かな場所で、目が合う。",
      pink: "少しだけ、あたたかい。",
      purple: "夢の端っこに触れる。"
    };

    const selected = save.story.chosenColor || "";
    const fallback = selected || "green";
    preview.dataset.kind="char"; preview.dataset.color=fallback; preview.dataset.state="open";
    preview.src = getAssetSrc("char", fallback, "open");

    colors.forEach(c => {
      const btn = document.createElement("button");
      btn.className = "choice" + (c === selected ? " selected" : "");
      btn.type="button";
      btn.innerHTML = `
        <img src="${getAssetSrc("char", c, "open")}" alt="${c}" data-kind="char" data-color="${c}" data-state="open">
        <div class="ctext">
          <div class="cname">${prettyColor(c)}</div>
          <div class="cdesc">${desc[c]}</div>
        </div>
        <div class="tiny">選ぶ</div>
      `;

      btn.addEventListener("mouseenter", () => { preview.dataset.color=c; preview.dataset.state="open"; preview.src = getAssetSrc("char", c, "open"); });
      btn.addEventListener("mouseleave", () => {
        const cur = save.story.chosenColor || fallback;
        preview.dataset.color=cur; preview.dataset.state="open"; preview.src = getAssetSrc("char", cur, "open");
      });

      btn.addEventListener("click", () => {
        save.story.chosenColor = c;
        saveNow();

        // 見た目だけ更新（全部作り直さずに選択状態だけ更新）
        [...box.querySelectorAll(".choice")].forEach(el => el.classList.remove("selected"));
        btn.classList.add("selected");
        preview.src = getAssetSrc("char", c, "open");
        updateStartButton();
      });

      box.appendChild(btn);
    });

    // 既に名前があるなら入力欄に反映
    const pn = $("playerName");
    if(pn && save.playerName && !pn.value) pn.value = save.playerName;

    wireTimeModeSelect();

    updateResumeBox();
    updateStartButton();
  }

  function updateStartButton(){
    const name = (($("playerName") && $("playerName").value) || "").trim();
    const hasName = name.length > 0;
    const hasChar = !!save.story.chosenColor;

    const btn = $("btn_start");
    if(btn) btn.disabled = !(hasName && hasChar);

    const tip = $("introNeed");
    if(!tip) return;

    if(hasName && hasChar) tip.textContent = "";
    else if(!hasName && !hasChar) tip.textContent = "名前と相棒を決めると、はじめられます。";
    else if(!hasName) tip.textContent = "呼ばれたい名前を入れると、はじめられます。";
    else tip.textContent = "相棒を選ぶと、はじめられます。";
  }


  function updateResumeBox(){
    const box = $("resumeBox");
    const meta = $("resumeMeta");
    const btn = $("btn_resume");
    if(!box || !meta || !btn) return;

    const hasProgress = !!(save && (save.life.isEnded || save.life.bornAt || save.story.arrivalAt || save.story.foundAt));
    const ready = !!(save && save.playerName && save.story.chosenColor && hasProgress);

    box.style.display = ready ? "block" : "none";
    if(!ready) return;

    let label = "";
    if(save.life.isEnded) label = "3日間が終わっています";
    else if(save.life.bornAt) label = `いまは Day ${dayIndex(save)}`;
    else if(save.story.arrivalAt) label = "マカロンが到着している";
    else label = "探している途中";
    meta.textContent = label;

    btn.onclick = () => { resumeToProgress(); };
  }

  function startFromOnboarding(){
    const name = (($('playerName') && $('playerName').value) || '').trim();
    const chosen = save.story.chosenColor;
    const modeSel = ($('timeMode') && $('timeMode').value) ? $('timeMode').value : (save.config && save.config.fast ? 'fast' : 'normal');

    if(!name || !chosen) return;

    // 一度きれいにしてから、名前と相棒だけ残す
    resetAll();
    // 時間設定を反映（新しく始めるときだけ）
    if(!save.config) save.config = {};
    save.config.fast = (modeSel === "fast");
    save.config.timeMode = modeSel;
    try{ localStorage.setItem(TIME_MODE_KEY, modeSel); }catch(e){}

    save.playerName = name;
    save.story.chosenColor = chosen;
    save.story.twinColor = pickTwinColor(chosen);

    // 探しもの探しへ
    resetSearch();
    buildMap();

    subline.textContent = name ? `○○（${name}）の記録` : "記録だけが残る";
    saveNow();
    showScreen("search");
  }

  function resetSearch(){
    save.story.foundAt = null;
    save.story.arrivalAt = null;
    save.story.hatchAt = null;
    save.story.hatched = false;
    save.story._targetTile = null;
    save.story._revealed = [];
    saveNow();
  }

  function buildMap(){
    const grid = $("mapGrid");
    grid.innerHTML = "";
    const N = 12;

    if(!save.story._targetTile){
      save.story._targetTile = Math.floor(Math.random()*N);
      save.story._revealed = [];
      saveNow();
    }

    const chosen = save.story.chosenColor || "blue";
    const macImg = getAssetSrc("macaron", chosen, "");

    for(let i=0;i<N;i++){
      const tile = document.createElement("button");
      tile.className = "tile";
      tile.type="button";
      tile.innerHTML = `<div class="spark"></div><span>……</span><img class="foundImg" alt="macaron">`;
      const img = tile.querySelector(".foundImg");
      img.src = macImg;

      if(save.story._revealed.includes(i)){
        tile.classList.add("revealed");
        tile.querySelector("span").textContent = " ";
        if(i === save.story._targetTile){
          tile.classList.add("found");
        }
      }

      tile.addEventListener("click", () => {
        if(save.story.foundAt) return;

        if(!save.story._revealed.includes(i)) save.story._revealed.push(i);
        tile.classList.add("revealed");
        tile.querySelector("span").textContent = " ";

        if(i === save.story._targetTile){
          tile.classList.add("found");
          save.story.foundAt = nowMs();

          // 見つけた瞬間に「到着」させる（誕生はそこから3分後）
          save.story.arrivalAt = effectiveNow(save);
          save.story.hatchAt = save.story.arrivalAt + hatchMsEff(save);
          save.story.hatched = false;

          $("searchNote").textContent = "見つかった。近づくと、温かい。";
          addEvent("found", { where: i, colorA: save.story.chosenColor, colorB: save.story.twinColor });
          saveNow();

          setTimeout(() => showArrival(), 650);
        }else{
          $("searchNote").textContent = "そこには、光の粒だけが残っている。";
          saveNow();
        }
      });

      grid.appendChild(tile);
    }
  }

  function showArrival(){
    showScreen("arrival");
    const c = save.story.chosenColor || "green";
    const ai = $("arrivalImg"); if(ai){ ai.dataset.kind="macaron"; ai.dataset.color=c; ai.src = getAssetSrc("macaron", c, ""); }
  }

  function maybeHatch(){
    if(save.story.hatched) return;
    if(!save.story.hatchAt) return;

    const t = effectiveNow(save);
    if(t >= save.story.hatchAt){
      save.story.hatched = true;

      const bornAt = save.story.hatchAt;
      save.life.bornAt = bornAt;
      save.life.deathAt = bornAt + lifeMsEff(save);
      save.life.isEnded = false;
      save.life.endedAt = null;
      save.life.revivedUntil = null;
      save.life.uncanny = false;
      save.life._handledEnd = false;

      save.logs.day["1"] = emptyDay(1);
      save.logs.day["2"] = emptyDay(2);
      save.logs.day["3"] = emptyDay(3);
      save.logs.events = [];
      save.logs.day["1"].heartStart = save.stats.hearts;

      addEvent("hatch", { colorA: save.story.chosenColor, colorB: save.story.twinColor });
      saveNow();
      showCare();
    }
  }

  function openChoiceModal(title, note, choices){
    modalTitle.textContent = title;
    modalNote.textContent = note;
    modalBtns.innerHTML = "";
    choices.forEach(ch => {
      const b = document.createElement("button");
      b.className = "btn " + (ch.style || "");
      b.textContent = ch.label;
      b.addEventListener("click", () => {
        closeModal();
        ch.onPick();
      });
      modalBtns.appendChild(b);
    });
    overlay.classList.add("on");
  }
  function closeModal(){ overlay.classList.remove("on"); }

  function applySoftImpact({ hunger=0, waste=0, mood=0, hearts=0 }){
    save.stats.hunger = clamp(save.stats.hunger + hunger, 0, 100);
    save.stats.waste  = clamp(save.stats.waste  + waste, 0, 100);

    const moodCap = save.life.uncanny ? 60 : 100;
    save.stats.mood = clamp(save.stats.mood + mood, 0, moodCap);

    const heartCap = save.life.uncanny ? Math.min(save.stats.hearts, 70) : 100;
    save.stats.hearts = clamp(save.stats.hearts + hearts, 0, heartCap);
  }

  function blockedByEnd(){ return save.life.isEnded; }

  // お世話（2択）
  function actFood(){
    if(blockedByEnd()) return;
    openChoiceModal(
      "食事",
      "軽くするか、しっかりにするか。理由は表示されない。",
      [
        { label:"軽い食事", style:"secondary", onPick: () => {
          applySoftImpact({ hunger: -18 + rnd(-2,2), waste: +10 + rnd(-2,2), mood: +4 + rnd(-1,1), hearts: +1 });
          addEvent("food", { choice: "light" });
          saveNow();
        }},
        { label:"しっかりした食事", onPick: () => {
          applySoftImpact({ hunger: -30 + rnd(-3,3), waste: +16 + rnd(-3,3), mood: +2 + rnd(-2,2), hearts: +1 });
          addEvent("food", { choice: "hearty" });
          saveNow();
        }}
      ]
    );
  }

  function actOuting(){
    if(blockedByEnd()) return;
    openChoiceModal(
      "お出かけ",
      "外へ出るか、家で過ごすか。",
      [
        { label:"外に出る", onPick: () => {
          applySoftImpact({ hunger: +8 + rnd(-2,2), waste: +8 + rnd(-2,2), mood: +10 + rnd(-2,2), hearts: +2 });
          addEvent("outing", { choice: "outside" });
          saveNow();
        }},
        { label:"家で過ごす", style:"secondary", onPick: () => {
          applySoftImpact({ hunger: +4 + rnd(-2,2), waste: +4 + rnd(-2,2), mood: +6 + rnd(-2,2), hearts: +1 });
          addEvent("outing", { choice: "home" });
          saveNow();
        }}
      ]
    );
  }

  
  // つまらないゲーム100（2択の集まり）
  const BORING_TOTAL = 100;
  const BORING_GAMES = buildBoringGames();

  function buildBoringGames(){
    // 10×10＝100個。内容は「意味があるようで、ない」くらいの温度。
    const nouns = ["ホコリ","影","余白","点","線","光","音","匂い","角","記憶"];
    const pairs = [
      ["数える","数えない"],
      ["なでる","見送る"],
      ["拾う","拾わない"],
      ["揃える","崩す"],
      ["近づく","離れる"],
      ["止まる","進む"],
      ["黙る","小さく言う"],
      ["揺らす","揺らさない"],
      ["隠す","出す"],
      ["待つ","急ぐ"]
    ];
    const templates = [
      "{N}をどうする？「{A}」/「{B}」",
      "{N}に、{A}？ それとも{B}？",
      "{A}ほうの{N} / {B}ほうの{N}",
      "{N}を、いったん{A} / そのまま{B}",
      "{N}は… {A} / {B}",
      "{N}と、{A} / {B}",
      "{A}してから{B} / {B}してから{A}",
      "きょうの{N}：{A} / {B}",
      "{N}を選ぶ：{A} / {B}",
      "{N}に対して：{A} / {B}"
    ];

    const list = [];
    let id = 1;
    for(let i=0;i<nouns.length;i++){
      for(let j=0;j<pairs.length;j++){
        const n = nouns[i];
        const a = pairs[j][0];
        const b = pairs[j][1];
        const t = templates[(i*3 + j) % templates.length];
        const q = t.replaceAll("{N}", n).replaceAll("{A}", a).replaceAll("{B}", b);
        list.push({ id, q, a, b });
        id++;
      }
    }
    return list.slice(0, BORING_TOTAL);
  }

  function miniChoiceKey(id, side){ return `g${id}${side}`; }
  function parseMiniChoiceKey(k){
    const m = /^g(\d{1,3})([AB])$/.exec(String(k||""));
    if(!m) return null;
    const id = parseInt(m[1],10);
    const side = m[2];
    if(!Number.isFinite(id) || id<1 || id> BORING_TOTAL) return null;
    return { id, side };
  }

  function bumpBoringPlay(){
    if(!save.stats) save.stats = { hunger:30, waste:20, mood:70, hearts:55 };
    save.stats.boringPlays = (save.stats.boringPlays || 0) + 1;

    // 20回ごとに「少し大きくなる」段階（数値は控えめに）
    const step = Math.floor(save.stats.boringPlays / 20);
    if(typeof save.stats.boringMilestone !== "number") save.stats.boringMilestone = 0;
    if(step > save.stats.boringMilestone){
      save.stats.boringMilestone = step;
      // 出来事として残したいなら、ここで addEvent("grow", { step }) も可能
    }
  }

  function actMini(){
    if(blockedByEnd()) return;

    const g = BORING_GAMES[Math.floor(Math.random()*BORING_GAMES.length)];
    openChoiceModal(
      "つまらないゲーム",
      `No.${g.id}/${BORING_TOTAL}  ${g.q}`,
      [
        { label: g.a, onPick: () => {
          bumpBoringPlay();
          applySoftImpact({ mood: +5 + rnd(-3,3), hearts: +1 });
          addEvent("mini", { gid: g.id, side: "A", choice: miniChoiceKey(g.id,"A") });
          saveNow();
          if(screens.care.classList.contains("active")) renderCare();
        }},
        { label: g.b, style:"secondary", onPick: () => {
          bumpBoringPlay();
          applySoftImpact({ mood: +5 + rnd(-3,3), hearts: +1 });
          addEvent("mini", { gid: g.id, side: "B", choice: miniChoiceKey(g.id,"B") });
          saveNow();
          if(screens.care.classList.contains("active")) renderCare();
        }}
      ]
    );
  }

  function actClean(){
    if(blockedByEnd()) return;
    openCleanMini();
  }

  // 排泄除去の小さなミニゲーム（クリックで消す）
  function openCleanMini(){
    modalTitle.textContent = "排泄除去";
    modalNote.textContent = "画面の中に出る汚れをクリックして消す。成功しても評価は出ない。";
    modalBtns.innerHTML = "";

    const area = document.createElement("div");
    area.style.position = "relative";
    area.style.height = "220px";
    area.style.borderRadius = "16px";
    area.style.border = "1px solid rgba(15,23,42,.14)";
    area.style.background = "rgba(255,255,255,.75)";
    area.style.overflow = "hidden";
    area.style.marginTop = "12px";

    const status = document.createElement("div");
    status.className = "tiny";
    status.style.marginTop = "10px";
    status.textContent = " ";

    const poopCount = 7;
    let removed = 0;
    let ended = false;

    function makeBlob(){
      const b = document.createElement("button");
      b.type="button";
      b.style.position="absolute";
      b.style.width = (18 + Math.random()*22) + "px";
      b.style.height = (14 + Math.random()*16) + "px";
      b.style.borderRadius = "12px";
      b.style.border = "1px solid rgba(15,23,42,.16)";
      b.style.background = "linear-gradient(180deg, rgba(15,23,42,.12), rgba(15,23,42,.28))";
      b.style.left = (8 + Math.random()*84) + "%";
      b.style.top = (8 + Math.random()*74) + "%";
      b.style.transform = `rotate(${Math.random()*22-11}deg)`;
      b.style.cursor = "pointer";
      b.style.boxShadow = "0 10px 18px rgba(15,23,42,.10)";
      b.addEventListener("click", () => {
        if(ended) return;
        b.remove();
        removed++;
        if(removed >= poopCount){
          finish(true);
        }
      });
      return b;
    }

    for(let i=0;i<poopCount;i++){
      area.appendChild(makeBlob());
    }

    const timer = document.createElement("div");
    timer.className = "tiny";
    timer.style.marginTop = "8px";
    let left = isFast(save) ? 6 : 12;

    const iv = setInterval(() => {
      if(ended) return;
      left--;
      if(left<=0){
        finish(false);
      }
    }, 1000);

    function finish(success){
      if(ended) return;
      ended = true;
      clearInterval(iv);

      if(success){
        applySoftImpact({ waste: -28 + rnd(-4,4), mood: +6 + rnd(-2,2), hearts: +1 });
        addEvent("clean", { choice: "done" });
      }else{
        applySoftImpact({ waste: -12 + rnd(-3,3), mood: +1 + rnd(-2,2), hearts: 0 });
        addEvent("clean", { choice: "partial" });
      }
      saveNow();
      closeModal();
    }

    const body = $("modalBody");
    body.innerHTML = "";
    body.appendChild(status);
    body.appendChild(area);
    body.appendChild(timer);

    overlay.classList.add("on");
  }

  // 生存中アイテム
  function actDrink(){
    if(blockedByEnd()) return;
    if(save.items.drink <= 0) return;
    openChoiceModal(
      "ドリンク",
      "生存中に使える。少しだけ戻る感じがする。理由は説明されない。",
      [
        { label:"飲ませる", onPick: () => {
          save.items.drink--;
          applySoftImpact({ hunger: -16 + rnd(-3,3), waste: -10 + rnd(-3,3), mood: +8 + rnd(-2,2), hearts: +1 });

          // 少しだけ寿命を延ばす（内部時間の調整）
          save.life.deathAt += (isFast(save) ? 6*1000 : 2*60*60*1000);

          addEvent("drink", {});
          saveNow();
        }},
        { label:"やめておく", style:"secondary", onPick: () => {} }
      ]
    );
  }

  // 死後アイテム
  function actMacaron(){
    if(!save.life.isEnded) return;
    if(save.items.macaron <= 0) return;

    openChoiceModal(
      "マカロン",
      "死後に使える。一時的に戻るが、完全には戻らない。",
      [
        { label:"使う", onPick: () => {
          save.items.macaron--;
          const t = effectiveNow(save);
          save.life.isEnded = false;
          save.life.endedAt = null;
          save.life.revivedUntil = t + (isFast(save) ? 22*1000 : 12*60*60*1000);
          save.life.uncanny = true;

          // どこか違和感のある復活
          save.stats.hunger = clamp(save.stats.hunger, 35, 85);
          save.stats.waste = clamp(save.stats.waste, 25, 90);
          save.stats.mood = clamp(save.stats.mood, 25, 55);

          addEvent("macaron", {});
          saveNow();
          showCare();
        }},
        { label:"やめておく", style:"secondary", onPick: () => {} }
      ]
    );
  }

  function maybeEnd(){
    if(!save.life.bornAt) return;

    const t = effectiveNow(save);

    if(save.life.revivedUntil && t >= save.life.revivedUntil){
      save.life.revivedUntil = null;
      save.life.isEnded = true;
      save.life.endedAt = t;
    }

    if(!save.life.revivedUntil && !save.life.isEnded){
      if(t >= save.life.deathAt){
        save.life.isEnded = true;
        save.life.endedAt = t;
      }
    }

    if(save.life.isEnded && !save.life._handledEnd){
      save.life._handledEnd = true;
      finalizeAllDaysAtEnd();
      addEvent("end", {});
      saveNow();
      showEnd();
    }
  }

  // 時間経過による状態変化（表示はしない）
  function stepByTime(dtMs){
    const dt = dtMs / 1000;

    const hungerRate = 100 / (isFast(save) ? 35 : (12*60*60));
    const wasteRate  = 100 / (isFast(save) ? 25 : (8*60*60));

    let hungerAdd = dt * hungerRate;
    let wasteAdd  = dt * wasteRate;

    if(save.life.uncanny){
      hungerAdd *= 1.25;
      wasteAdd  *= 1.25;
    }

    save.stats.hunger = clamp(save.stats.hunger + hungerAdd, 0, 100);
    save.stats.waste  = clamp(save.stats.waste  + wasteAdd, 0, 100);

    let moodDrop = 0;
    if(save.stats.hunger > 70) moodDrop += (dt * 0.020);
    if(save.stats.waste > 70) moodDrop += (dt * 0.024);
    if(save.stats.hunger > 85) moodDrop += (dt * 0.028);
    if(save.stats.waste > 85) moodDrop += (dt * 0.032);

    let moodRise = 0;
    if(save.stats.hunger < 45 && save.stats.waste < 45){
      moodRise += dt * 0.010;
    }

    const moodCap = save.life.uncanny ? 60 : 100;
    save.stats.mood = clamp(save.stats.mood - moodDrop + moodRise, 0, moodCap);

    if(save.stats.hunger > 85 || save.stats.waste > 85){
      save.stats.hearts = clamp(save.stats.hearts - dt*0.0012, 0, save.life.uncanny ? Math.min(save.stats.hearts,70) : 100);
    }else if(save.stats.mood > 75 && save.stats.hunger < 55 && save.stats.waste < 55){
      save.stats.hearts = clamp(save.stats.hearts + dt*0.0006, 0, save.life.uncanny ? Math.min(save.stats.hearts,70) : 100);
    }
  }

  // 状態はラベル表示しない。表情と動きだけで見せる
  function stateKind(){
    const { hunger, waste, mood } = save.stats;
    const bad = (hunger > 80) + (waste > 80);
    if(save.life.isEnded) return "ended";
    if(bad >= 2 || mood < 22) return "cry";
    if(bad >= 1 || mood < 45) return "sad";
    if(mood > 72 && hunger < 60 && waste < 60) return "happy";
    return "ok";
  }


  // 生まれた直後は小さく、3日で少しずつ大きくなる（カウントダウン表示はしない）
// 左＝ユーザーが選んだ子、右＝生まれてきた子（最初は右が少し小さい）
function growthScalesLive(){
  if(!save.life.bornAt) return { a:0.50, b:0.36, p:0, bonus:0 };
  const eff = effectiveNow(save);

  // 終了後は、その時点で止める
  const endT = save.life.isEnded ? (save.life.endedAt || save.life.deathAt) : save.life.deathAt;
  const denom = Math.max(1, endT - save.life.bornAt);
  const t = clamp(eff - save.life.bornAt, 0, denom);
  const p = t / denom;

  const aMin = 0.50;
  const aMax = 1.05;
  const bMin = 0.36;
  const bMax = 1.05;

  const baseA = aMin + (aMax - aMin) * p;
  const baseB = bMin + (bMax - bMin) * p;

  // つまらないゲーム：20回ごとに、少しだけ大きくなる（控えめ、上限あり）
  const plays = (save.stats && typeof save.stats.boringPlays === "number") ? save.stats.boringPlays : 0;
  const step = Math.floor(plays / 20);
  const bonus = clamp(step * 0.03, 0, 0.15);

  return {
    a: clamp(baseA + bonus, 0.20, 1.25),
    b: clamp(baseB + bonus, 0.20, 1.25),
    p,
    bonus
  };
}

function separationFromScale(sc){
    // 小さいほど離れて見え、大きいほど少し寄り添う
    const p = clamp((sc-0.50)/(1.05-0.50), 0, 1);
    const sep = 96 - 38*p; // px
    return `${sep.toFixed(1)}px`;
  }

  // 状態はラベル表示しない。表情と動きだけで見せる
  function renderCare(){
    ensureTwinColors();
    const a = save.story.chosenColor || "green";
    const b = save.story.twinColor || pickTwinColor(a);

    $("btn_drink").disabled = save.life.isEnded || save.items.drink<=0;
    $("btn_macaron").disabled = (!save.life.isEnded) || save.items.macaron<=0;

    const kind = stateKind();

    const pair = $("charPair");
    const imgA = $("charImg");
    const imgB = $("charImg2");
    const tear = $("tear");
    const poops = [ $("po1"), $("po2"), $("po3"), $("po4") ];
    const useOpenA = (kind === "happy") || (kind === "cry" && (a==="blue" || a==="pink"));
    const useOpenB = (kind === "happy") || (kind === "cry" && (b==="blue" || b==="pink"));
    const srcA = useOpenA ? getAssetSrc("char", a, "open") : getAssetSrc("char", a, "closed");
    const srcB = useOpenB ? getAssetSrc("char", b, "open") : getAssetSrc("char", b, "closed");
    imgA.dataset.kind="char"; imgA.dataset.color=a; imgA.dataset.state = useOpenA ? "open" : "closed";
    imgB.dataset.kind="char"; imgB.dataset.color=b; imgB.dataset.state = useOpenB ? "open" : "closed";
    imgA.src = srcA;
    imgB.src = srcB;

    // 成長反映
    const gs = growthScalesLive();
    pair.style.setProperty("--growA", gs.a.toFixed(3));
    pair.style.setProperty("--growB", gs.b.toFixed(3));
    const scMean = (gs.a + gs.b) / 2;
    pair.style.setProperty("--sep", separationFromScale(scMean));

    // クラス整理
    pair.classList.remove("k-ok","k-happy","k-sad","k-cry","k-ended","uncanny");
    tear.classList.remove("on");

    if(kind === "happy"){
      pair.classList.add("k-happy");
    }else if(kind === "ok"){
      pair.classList.add("k-ok");
    }else if(kind === "sad"){
      pair.classList.add("k-sad");
      tear.classList.add("on");
    }else if(kind === "cry"){
      pair.classList.add("k-cry");
      tear.classList.add("on");
    }else if(kind === "ended"){
      pair.classList.add("k-ended");
    }

    if(save.life.uncanny && !save.life.isEnded){
      pair.classList.add("uncanny");
    }

    const dirty = save.stats.waste > 70;
    poops.forEach(p => p.classList.toggle("on", dirty));

    const h = save.stats.hearts;
    const level = Math.round(clamp(h,0,100)/20);
    [ $("h1"),$("h2"),$("h3"),$("h4"),$("h5") ].forEach((el,i)=>{
      el.classList.toggle("on", i < level);
    });

    const tgl = $("toggle_sitter");
    tgl.classList.toggle("on", save.sitter.on);
    tgl.setAttribute("aria-checked", save.sitter.on ? "true":"false");
    $("sitterNote").textContent = save.sitter.on ? "止まっている" : "時間は止まる";

    $("endNote").style.display = save.life.isEnded ? "block" : "none";

    // 残り時間（数値の評価ではなく、目安として表示）
    const tc = $("timeCounter");
    if(tc){
      tc.textContent = formatRemainingMs(remainingMs(save));
    }

    const hint = $("careHint");
    if(save.life.uncanny && !save.life.isEnded){
      hint.textContent = "戻ってきた。でも、どこか違う気がする。";
    }else{
      hint.textContent = "言葉ではわからない。表情と動きだけが変わる。";
    }
  }
  function showCare(){
    ensureTwinColors();
    showScreen("care");
    renderCare();
  }

  function showEnd(){
    showScreen("end");
  }

  function resumeToProgress(){
    if(!save.playerName || !save.story.chosenColor){
      renderOnboarding();
      return;
    }
    if(save.life.isEnded){
      showEnd();
    }else if(save.life.bornAt){
      showCare();
    }else if(save.story.arrivalAt){
      showArrival();
    }else{
      buildMap();
      showScreen("search");
    }
  }

  function msToHuman(ms){
    if(!ms || ms<=0) return "0分";
    const m = Math.round(ms/60000);
    if(m < 60) return `${m}分`;
    const h = Math.floor(m/60);
    const mm = m%60;
    return `${h}時間${mm}分`;
  }

  function summarizeChoices(choices){
    const out = [];
    const mapCount = (arr) => arr.reduce((acc,x)=>{ acc[x]=(acc[x]||0)+1; return acc; }, {});
    const tFood = mapCount(choices.food || []);
    const tOut = mapCount(choices.outing || []);
    const tMini = mapCount(choices.mini || []);
    const tClean = mapCount(choices.clean || []);

    if(Object.keys(tFood).length){
      out.push(`食事の選択: ${Object.entries(tFood).map(([k,v])=>`${foodLabel(k)}×${v}`).join(" / ")}`);
    }
    if(Object.keys(tOut).length){
      out.push(`お出かけの選択: ${Object.entries(tOut).map(([k,v])=>`${outingLabel(k)}×${v}`).join(" / ")}`);
    }
    if(Object.keys(tMini).length){
      out.push(`つまらないゲームの選択: ${Object.entries(tMini).map(([k,v])=>`${miniLabel(k)}×${v}`).join(" / ")}`);
    }
    if(Object.keys(tClean).length){
      out.push(`排泄除去: ${Object.entries(tClean).map(([k,v])=>`${cleanLabel(k)}×${v}`).join(" / ")}`);
    }
    if(!out.length) out.push("選択: （記録なし）");
    return out;
  }
  function foodLabel(k){ return k==="light" ? "軽い" : (k==="hearty" ? "しっかり" : k); }
  function outingLabel(k){ return k==="outside" ? "外" : (k==="home" ? "家" : k); }
  function miniLabel(k){
    const parsed = (typeof parseMiniChoiceKey === "function") ? parseMiniChoiceKey(k) : null;
    if(parsed){
      const g = (typeof BORING_GAMES !== "undefined") ? (BORING_GAMES[parsed.id-1] || null) : null;
      if(g){
        const lab = (parsed.side === "A") ? g.a : g.b;
        return `#${parsed.id} ${lab}`;
      }
      return `#${parsed.id}`;
    }
    // 旧ミニゲーム互換
    const m = { collect:"集める", watch:"眺める", near:"近づく", far:"離れる", touch:"触れる", watch2:"見守る" };
    return m[k] || k;
  }
  function cleanLabel(k){ return k==="done" ? "完了" : (k==="partial" ? "途中" : k); }

  function eventToText(e){
    const t = e.type;
    if(t==="chooseChar") return `キャラ選択（${prettyColor(e.detail.color)}）`;
    if(t==="found") return "見つけた";
    if(t==="hatch") return "誕生した";
    if(t==="food") return `食事（${foodLabel(e.detail.choice)}）`;
    if(t==="outing") return `お出かけ（${outingLabel(e.detail.choice)}）`;
    if(t==="mini"){
      const c = (e.detail && e.detail.choice!=null) ? e.detail.choice : ((e.detail && e.detail.gid) ? miniChoiceKey(e.detail.gid, e.detail.side||"A") : "");
      return `つまらない（${miniLabel(c)}）`;
    }
    if(t==="clean") return `排泄除去（${cleanLabel(e.detail.choice)}）`;
    if(t==="drink") return "ドリンク";
    if(t==="macaron") return "マカロン";
    if(t==="sitterOn") return "シッターON";
    if(t==="sitterOff") return "シッターOFF";
    if(t==="end") return "終わった";
    return t;
  }

  function buildHeartSeriesFromSave(s){
    const arr = [];
    for(let d=1; d<=3; d++){
      const obj = s.logs.day[String(d)];
      const start = (obj && obj.heartStart!=null) ? obj.heartStart : null;
      const end = (obj && obj.heartEnd!=null) ? obj.heartEnd : ((d===dayIndex(s)) ? s.stats.hearts : null);
      if(end!=null) arr.push({ x:d, y:end });
      else if(start!=null) arr.push({ x:d, y:start });
      else arr.push({ x:d, y:null });
    }
    return arr;
  }

  function drawHeartChart(canvas, series){
    const ctx = canvas.getContext("2d");
    const W = canvas.width, H = canvas.height;
    ctx.clearRect(0,0,W,H);

    ctx.globalAlpha = 1;
    ctx.strokeStyle = "rgba(15,23,42,.18)";
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(36, 18);
    ctx.lineTo(36, H-28);
    ctx.lineTo(W-14, H-28);
    ctx.stroke();

    ctx.fillStyle = "rgba(15,23,42,.70)";
    ctx.font = "12px system-ui, sans-serif";
    for(let d=1; d<=3; d++){
      const x = mapX(d);
      ctx.fillText("D"+d, x-8, H-10);
    }

    const pts = series.filter(p => p.y!=null).map(p => ({ x:mapX(p.x), y:mapY(p.y) }));
    if(pts.length>=2){
      ctx.strokeStyle = "rgba(251,113,133,.88)";
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(pts[0].x, pts[0].y);
      for(let i=1;i<pts.length;i++) ctx.lineTo(pts[i].x, pts[i].y);
      ctx.stroke();
    }
    pts.forEach(p => {
      ctx.fillStyle = "rgba(251,113,133,.92)";
      ctx.beginPath();
      ctx.arc(p.x, p.y, 4, 0, Math.PI*2);
      ctx.fill();
    });

    function mapX(day){
      const left = 36, right = W-14;
      return left + (right-left)*( (day-1)/2 );
    }
    function mapY(val){
      const top = 18, bottom = H-28;
      const y = clamp(val,0,100);
      return bottom - (bottom-top)*(y/100);
    }
  }

  function showLogs(){
    showScreen("logs");
    const tabs = $("dayTabs");
    const box = $("logBox");
    tabs.innerHTML = "";
    box.innerHTML = "";

    for(let d=1; d<=3; d++){
      const b = document.createElement("button");
      b.className = "tab";
      b.type="button";
      b.textContent = `Day ${d}`;
      b.addEventListener("click", () => renderDay(d));
      tabs.appendChild(b);
    }
    renderDay(dayIndex(save) || 1);

    drawHeartChart($("heartChart"), buildHeartSeriesFromSave(save));

    function renderDay(d){
      [...tabs.children].forEach((t,i)=>t.classList.toggle("active", i===d-1));
      box.innerHTML = "";

      const obj = save.logs.day[String(d)] || emptyDay(d);
      const heartStart = obj.heartStart;
      const heartEnd = (obj.heartEnd != null) ? obj.heartEnd : ((d===dayIndex(save)) ? save.stats.hearts : null);
      const delta = (heartStart!=null && heartEnd!=null) ? (heartEnd-heartStart) : null;

      const lines = [];
      lines.push(`Day ${d}`);
      if(heartStart!=null && heartEnd!=null){
        const sign = delta>=0 ? "+" : "";
        lines.push(`ハートの変化: ${sign}${Math.round(delta)}`);
      }else{
        lines.push(`ハートの変化: （未確定）`);
      }

      lines.push(`お世話: 食事${obj.careCounts.food} / お出かけ${obj.careCounts.outing} / つまらない${obj.careCounts.mini} / 排泄除去${obj.careCounts.clean}`);
      lines.push(`アイテム: ドリンク${obj.careCounts.drink} / マカロン${obj.careCounts.macaron}`);
      lines.push(`シッター: ${msToHuman(obj.sitterMs)}`);

      const cLines = summarizeChoices(obj.choices);
      cLines.forEach(s => lines.push(s));

      const evs = save.logs.events.filter(e => e.day===d);
      if(evs.length){
        lines.push(`出来事:`);
        evs.slice(0,120).forEach(e => {
          lines.push(`  ${formatTime(e.t)}  ${eventToText(e)}`);
        });
      }else{
        lines.push(`出来事: （なし）`);
      }

      lines.forEach(s => {
        const div = document.createElement("div");
        div.className = "logLine";
        div.textContent = s;
        box.appendChild(div);
      });
    }
  }

  // シッター切り替え（時間停止）
  function toggleSitter(force=null){
    if(!save.life.bornAt) return;
    if(save.life.isEnded) return;

    const wantOn = (force!=null) ? force : !save.sitter.on;

    if(wantOn && !save.sitter.on){
      save.sitter.on = true;
      save.sitter.onSince = nowMs();
      addEvent("sitterOn", {});
      saveNow();
      renderCare();
      return;
    }
    if(!wantOn && save.sitter.on){
      const used = nowMs() - save.sitter.onSince;
      save.sitter.on = false;
      save.sitter.pausedTotal += used;
      save.sitter.usedTotal += used;

      const d = dayIndex(save);
      const obj = save.logs.day[String(d)];
      if(obj) obj.sitterMs += used;

      save.sitter.onSince = null;
      addEvent("sitterOff", { ms: used });
      saveNow();
      renderCare();
      return;
    }
  }

  function tick(){
    if(!save) return;

    // まだ誕生前（到着待ち）
    if(save.story.arrivalAt && !save.story.hatched){
      maybeHatch();
      return;
    }

    if(save.life.bornAt){
      const prevDay = save._prevDay || dayIndex(save);
      const curDay = dayIndex(save);
      finalizeDayIfNeeded(prevDay, curDay);
      save._prevDay = curDay;

      const effNow = effectiveNow(save);
      const last = save._lastEff || effNow;
      const dt = effNow - last;

      if(dt > 0 && !save.sitter.on && !save.life.isEnded){
        stepByTime(dt);
      }
      save._lastEff = effNow;

      ensureDayHearts();
      maybeEnd();

      if(screens.care.classList.contains("active")){
        renderCare();
      }

      saveNow();
    }
  }

  // 初期化（プレイ）
  function initPlay(){
    initTopNav();
    applyLang();
    setModePill();
    save = loadSave();

    normalizeSaveConfig();

    if(save.playerName){
      $("playerName").value = save.playerName;
      subline.textContent = save.playerName ? `○○（${save.playerName}）の記録` : "記録だけが残る";
    }
    // 画面遷移：まずは物語の入口（必要なら"つづきから"）
    // 最初はすぐ表示し、画像は見つかったものから差し替えます
    renderOnboarding();
    // よく使うものだけ先に探し始める（表示を早く安定させる）
    ["green","blue","pink","purple"].forEach(c => getAssetSrc("char", c, "open"));
    ["green","blue","pink","purple"].forEach(c => getAssetSrc("macaron", c, ""));


    // ボタン
    const pn = $("playerName");
    if(pn){
      pn.addEventListener("input", () => {
        save.playerName = pn.value;
        saveNow();
        updateStartButton();
      });
    }

    const startBtn = $("btn_start");
    if(startBtn){
      startBtn.addEventListener("click", () => startFromOnboarding());
    }

    $("btn_new_reset").addEventListener("click", () => {
      // 保存を消して、最初に戻る
      resetAll();
      if(pn) pn.value = "";
      renderOnboarding();
    });

    const backIntroBtn = $("btn_back_intro");
    if(backIntroBtn){
      backIntroBtn.addEventListener("click", () => {
        // 進行中なら、軽く確認する
        if(save.story.arrivalAt || save.life.bornAt){
          openChoiceModal("設定へ戻る", "相棒や名前を変えると、探し直しになります。どうしますか？", [
            { label:"戻る", cls:"secondary", onClick: () => { renderOnboarding(); } },
            { label:"やめる", cls:"blue", onClick: () => {} }
          ]);
        }else{
          renderOnboarding();
        }
      });
    }

    $("btn_back_search").addEventListener("click", () => {
      resetSearch();
      buildMap();
      showScreen("search");
      $("searchNote").textContent = "まだ、何も見つからない。";
    });

    $("btn_hint").addEventListener("click", () => {
      if(save.story.foundAt) return;
      const N=12;
      const i = Math.floor(Math.random()*N);
      if(!save.story._revealed.includes(i)) save.story._revealed.push(i);
      saveNow();
      buildMap();
      $("searchNote").textContent = "光の粒が、少しだけ道を示した。";
    });

    $("btn_new_reset").addEventListener("click", () => {
      resetAll();
      showScreen("intro");
      $("searchNote").textContent = "まだ、何も見つからない。";
    });

    // お世話
    $("btn_food").addEventListener("click", actFood);
    $("btn_outing").addEventListener("click", actOuting);
    $("btn_mini").addEventListener("click", actMini);
    $("btn_clean").addEventListener("click", actClean);
    $("btn_drink").addEventListener("click", actDrink);
    $("btn_macaron").addEventListener("click", actMacaron);

    $("btn_logs").addEventListener("click", () => showLogs());
    $("btn_back_care").addEventListener("click", () => {
      if(save.life.isEnded) showEnd();
      else showCare();
    });

    // モーダル
    $("btn_close_modal").addEventListener("click", () => overlay.classList.remove("on"));
    overlay.addEventListener("click", (e) => {
      if(e.target === overlay) overlay.classList.remove("on");
    });

    // シッター
    const tgl = $("toggle_sitter");
    tgl.addEventListener("click", () => toggleSitter());
    tgl.addEventListener("keydown", (e) => {
      if(e.key === "Enter" || e.key === " "){
        e.preventDefault();
        toggleSitter();
      }
    });

    $("btn_end_logs").addEventListener("click", () => showLogs());

    // タイマー
    if(tickTimer) clearInterval(tickTimer);
    tickTimer = setInterval(tick, 900);
    tick();
  }

  initPlay();
})();
</script>
</body>
</html>
